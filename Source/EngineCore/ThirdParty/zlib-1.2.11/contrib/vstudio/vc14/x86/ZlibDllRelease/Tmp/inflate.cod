; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateCodesUsed@4
PUBLIC	_inflateMark@4
PUBLIC	_inflateValidate@8
PUBLIC	_inflateUndermine@8
PUBLIC	_inflateCopy@8
PUBLIC	_inflateSyncPoint@4
PUBLIC	_inflateSync@4
PUBLIC	_inflateGetHeader@8
PUBLIC	_inflateSetDictionary@12
PUBLIC	_inflateGetDictionary@12
PUBLIC	_inflatePrime@12
PUBLIC	_inflateInit_@12
PUBLIC	_inflateReset2@8
PUBLIC	_inflateResetKeep@4
PUBLIC	_inflateEnd@4
PUBLIC	_inflate@8
PUBLIC	_inflateInit2_@16
PUBLIC	_inflateReset@4
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateRes
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 155  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateRes:

; 150  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 151  :     state->wsize = 0;
; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;
; 154  :     return inflateResetKeep(strm);

  0001b	89 4d 08	 mov	 DWORD PTR _strm$[ebp], ecx
  0001e	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  00025	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
  0002c	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 155  : }

  00033	5d		 pop	 ebp

; 151  :     state->wsize = 0;
; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;
; 154  :     return inflateResetKeep(strm);

  00034	e9 00 00 00 00	 jmp	 _inflateResetKeep@4
_inflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 201  :     int ret;
; 202  :     struct inflate_state FAR *state;
; 203  : 
; 204  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 ac 00 00
	00		 je	 $LN3@inflateIni
  0000e	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00011	0f 85 a3 00 00
	00		 jne	 $LN3@inflateIni
  00017	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001b	0f 85 99 00 00
	00		 jne	 $LN3@inflateIni

; 207  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00025	85 f6		 test	 esi, esi
  00027	75 08		 jne	 SHORT $LN4@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 237  : }

  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
$LN4@inflateIni:

; 208  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 209  :     if (strm->zalloc == (alloc_func)0) {

  00031	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00035	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003c	75 0e		 jne	 SHORT $LN5@inflateIni

; 210  : #ifdef Z_SOLO
; 211  :         return Z_STREAM_ERROR;
; 212  : #else
; 213  :         strm->zalloc = zcalloc;

  0003e	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 214  :         strm->opaque = (voidpf)0;

  00045	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
$LN5@inflateIni:

; 215  : #endif
; 216  :     }
; 217  :     if (strm->zfree == (free_func)0)

  0004c	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00050	75 07		 jne	 SHORT $LN6@inflateIni

; 218  : #ifdef Z_SOLO
; 219  :         return Z_STREAM_ERROR;
; 220  : #else
; 221  :         strm->zfree = zcfree;

  00052	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN6@inflateIni:

; 222  : #endif
; 223  :     state = (struct inflate_state FAR *)

  00059	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0005c	57		 push	 edi
  0005d	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00062	6a 01		 push	 1
  00064	ff 76 28	 push	 DWORD PTR [esi+40]
  00067	ff d0		 call	 eax
  00069	8b f8		 mov	 edi, eax
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 224  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 225  :     if (state == Z_NULL) return Z_MEM_ERROR;

  0006e	85 ff		 test	 edi, edi
  00070	75 09		 jne	 SHORT $LN7@inflateIni
  00072	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 237  : }

  00077	5d		 pop	 ebp
  00078	c2 10 00	 ret	 16			; 00000010H
$LN7@inflateIni:
  0007b	53		 push	 ebx

; 226  :     Tracev((stderr, "inflate: allocated\n"));
; 227  :     strm->state = (struct internal_state FAR *)state;
; 228  :     state->strm = strm;
; 229  :     state->window = Z_NULL;
; 230  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 231  :     ret = inflateReset2(strm, windowBits);

  0007c	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  0007f	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00082	56		 push	 esi
  00083	89 37		 mov	 DWORD PTR [edi], esi
  00085	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
  0008c	c7 47 04 34 3f
	00 00		 mov	 DWORD PTR [edi+4], 16180 ; 00003f34H
  00093	e8 00 00 00 00	 call	 _inflateReset2@8
  00098	8b d8		 mov	 ebx, eax

; 232  :     if (ret != Z_OK) {

  0009a	85 db		 test	 ebx, ebx
  0009c	74 13		 je	 SHORT $LN8@inflateIni

; 233  :         ZFREE(strm, state);

  0009e	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  000a1	57		 push	 edi
  000a2	ff 76 28	 push	 DWORD PTR [esi+40]
  000a5	ff d1		 call	 ecx
  000a7	83 c4 08	 add	 esp, 8

; 234  :         strm->state = Z_NULL;

  000aa	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN8@inflateIni:

; 235  :     }
; 236  :     return ret;

  000b1	8b c3		 mov	 eax, ebx
  000b3	5b		 pop	 ebx
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi

; 237  : }

  000b6	5d		 pop	 ebp
  000b7	c2 10 00	 ret	 16			; 00000010H
$LN3@inflateIni:

; 205  :         stream_size != (int)(sizeof(z_stream)))
; 206  :         return Z_VERSION_ERROR;

  000ba	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH

; 237  : }

  000bf	5d		 pop	 ebp
  000c0	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflate@8
_TEXT	SEGMENT
_copy$11$ = -64						; size = 4
tv2834 = -60						; size = 4
_in$1$ = -56						; size = 4
$T1 = -52						; size = 4
_copy$9$ = -52						; size = 4
tv2814 = -52						; size = 4
tv2767 = -52						; size = 4
tv2766 = -52						; size = 4
tv2753 = -52						; size = 4
tv2737 = -52						; size = 4
tv2722 = -52						; size = 4
tv2720 = -52						; size = 4
tv2709 = -52						; size = 4
tv2707 = -52						; size = 4
tv2665 = -52						; size = 4
_copy$7$ = -52						; size = 4
_copy$4$ = -52						; size = 4
_copy$3$ = -52						; size = 4
_copy$2$ = -52						; size = 4
_len$5$ = -52						; size = 4
_len$1$ = -52						; size = 4
_last$ = -52						; size = 4
_here$ = -52						; size = 4
tv2837 = -48						; size = 4
_ret$1$ = -44						; size = 4
_from$1$ = -40						; size = 4
_copy$8$ = -40						; size = 4
tv2843 = -40						; size = 4
tv2735 = -40						; size = 4
tv2706 = -40						; size = 4
_copy$1$ = -40						; size = 4
_len$4$ = -40						; size = 4
_len$3$ = -40						; size = 4
_len$2$ = -40						; size = 4
_out$1$ = -36						; size = 4
_put$1$ = -32						; size = 4
_hbuf$ = -28						; size = 4
_left$1$ = -24						; size = 4
tv2734 = -20						; size = 4
tv2732 = -20						; size = 4
_bits$1$ = -20						; size = 4
tv2761 = -16						; size = 4
tv2760 = -16						; size = 4
_next$1$ = -16						; size = 4
tv2764 = -12						; size = 4
_have$1$ = -12						; size = 4
_state$1$ = -8						; size = 4
_hold$1$ = -4						; size = 4
tv2690 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 626  :     struct inflate_state FAR *state;
; 627  :     z_const unsigned char FAR *next;    /* next input */
; 628  :     unsigned char FAR *put;     /* next output */
; 629  :     unsigned have, left;        /* available input and output */
; 630  :     unsigned long hold;         /* bit buffer */
; 631  :     unsigned bits;              /* bits in bit buffer */
; 632  :     unsigned in, out;           /* save starting available input and output */
; 633  :     unsigned copy;              /* number of stored or match bytes to copy */
; 634  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 635  :     code here;                  /* current decoding table entry */
; 636  :     code last;                  /* parent table entry */
; 637  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 638  :     int ret;                    /* return code */
; 639  : #ifdef GUNZIP
; 640  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 641  : #endif
; 642  :     static const unsigned short order[19] = /* permutation of code lengths */
; 643  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 644  : 
; 645  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	83 ec 40	 sub	 esp, 64			; 00000040H
  00009	8b ca		 mov	 ecx, edx
  0000b	e8 00 00 00 00	 call	 _inflateStateCheck
  00010	85 c0		 test	 eax, eax
  00012	0f 85 ab 16 00
	00		 jne	 $LN333@inflate
  00018	39 42 0c	 cmp	 DWORD PTR [edx+12], eax
  0001b	0f 84 a2 16 00
	00		 je	 $LN333@inflate
  00021	39 02		 cmp	 DWORD PTR [edx], eax
  00023	75 09		 jne	 SHORT $LN332@inflate
  00025	39 42 04	 cmp	 DWORD PTR [edx+4], eax
  00028	0f 85 95 16 00
	00		 jne	 $LN333@inflate
$LN332@inflate:

; 648  : 
; 649  :     state = (struct inflate_state FAR *)strm->state;

  0002e	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00031	89 4d f8	 mov	 DWORD PTR _state$1$[ebp], ecx

; 650  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00034	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  0003b	75 07		 jne	 SHORT $LN4@inflate
  0003d	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H
$LN4@inflate:

; 651  :     LOAD();

  00044	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00047	89 45 e0	 mov	 DWORD PTR _put$1$[ebp], eax
  0004a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0004d	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax

; 652  :     in = have;
; 653  :     out = left;

  00050	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax

; 654  :     ret = Z_OK;

  00053	33 c0		 xor	 eax, eax
  00055	53		 push	 ebx
  00056	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00059	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  0005c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0005f	56		 push	 esi
  00060	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00063	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00068	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0006b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0006e	89 5d c8	 mov	 DWORD PTR _in$1$[ebp], ebx
  00071	57		 push	 edi
  00072	8b 3a		 mov	 edi, DWORD PTR [edx]
  00074	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00077	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0007a	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0007d	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00080	0f 87 08 0b 00
	00		 ja	 $LN499@inflate

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  00086	8d 79 58	 lea	 edi, DWORD PTR [ecx+88]
  00089	89 7d d0	 mov	 DWORD PTR tv2837[ebp], edi

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  0008c	8d 79 5c	 lea	 edi, DWORD PTR [ecx+92]
  0008f	89 7d c4	 mov	 DWORD PTR tv2834[ebp], edi
  00092	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
$LL5@inflate:

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  00095	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN936@inflate[eax*4]
$LN335@inflate:

; 657  :         case HEAD:
; 658  :             if (state->wrap == 0) {

  0009c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0009f	89 45 cc	 mov	 DWORD PTR tv2814[ebp], eax
  000a2	85 c0		 test	 eax, eax
  000a4	75 0c		 jne	 SHORT $LN12@inflate

; 659  :                 state->mode = TYPEDO;

  000a6	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H

; 660  :                 break;

  000ad	e9 cb 0a 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  000b2	83 fe 10	 cmp	 esi, 16			; 00000010H
  000b5	73 2d		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000b7	85 db		 test	 ebx, ebx
  000b9	0f 84 ff 04 00
	00		 je	 $LN887@inflate
  000bf	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000c2	8b ce		 mov	 ecx, esi
  000c4	d3 e0		 shl	 eax, cl
  000c6	83 c6 08	 add	 esi, 8
  000c9	4b		 dec	 ebx
  000ca	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  000cd	03 d0		 add	 edx, eax
  000cf	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  000d2	47		 inc	 edi
  000d3	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  000d6	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  000d9	83 fe 10	 cmp	 esi, 16			; 00000010H
  000dc	72 d9		 jb	 SHORT $LL13@inflate
  000de	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000e1	8b 45 cc	 mov	 eax, DWORD PTR tv2814[ebp]
$LN10@inflate:

; 663  : #ifdef GUNZIP
; 664  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000e4	a8 02		 test	 al, 2
  000e6	74 54		 je	 SHORT $LN338@inflate
  000e8	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000ee	75 4c		 jne	 SHORT $LN338@inflate

; 665  :                 if (state->wbits == 0)

  000f0	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  000f4	75 07		 jne	 SHORT $LN339@inflate

; 666  :                     state->wbits = 15;

  000f6	c7 41 28 0f 00
	00 00		 mov	 DWORD PTR [ecx+40], 15	; 0000000fH
$LN339@inflate:

; 667  :                 state->check = crc32(0L, Z_NULL, 0);

  000fd	6a 00		 push	 0
  000ff	6a 00		 push	 0
  00101	6a 00		 push	 0
  00103	e8 00 00 00 00	 call	 _crc32@12
  00108	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 668  :                 CRC2(state->check, hold);

  0010b	6a 02		 push	 2
  0010d	66 c7 45 e4 1f
	8b		 mov	 WORD PTR _hbuf$[ebp], 35615 ; 00008b1fH
  00113	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00116	8d 4d e4	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00119	51		 push	 ecx
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 _crc32@12
  00120	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 669  :                 INITBITS();

  00123	33 d2		 xor	 edx, edx
  00125	33 f6		 xor	 esi, esi
  00127	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0012a	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0012d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 670  :                 state->mode = FLAGS;

  00130	c7 41 04 35 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16181 ; 00003f35H

; 671  :                 break;

  00137	e9 41 0a 00 00	 jmp	 $LN8@inflate
$LN338@inflate:

; 672  :             }
; 673  :             state->flags = 0;           /* expect zlib header */
; 674  :             if (state->head != Z_NULL)

  0013c	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0013f	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00146	85 c0		 test	 eax, eax
  00148	74 07		 je	 SHORT $LN340@inflate

; 675  :                 state->head->done = -1;

  0014a	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN340@inflate:

; 676  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  00151	f6 41 0c 01	 test	 BYTE PTR [ecx+12], 1
  00155	0f 84 cc 00 00
	00		 je	 $LN342@inflate
  0015b	0f b6 ca	 movzx	 ecx, dl
  0015e	8b c2		 mov	 eax, edx
  00160	c1 e1 08	 shl	 ecx, 8
  00163	33 d2		 xor	 edx, edx
  00165	c1 e8 08	 shr	 eax, 8
  00168	03 c1		 add	 eax, ecx
  0016a	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0016f	f7 f1		 div	 ecx

; 687  :                 state->mode = BAD;

  00171	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00174	85 d2		 test	 edx, edx
  00176	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00179	0f 85 a8 00 00
	00		 jne	 $LN342@inflate

; 684  :             }
; 685  :             if (BITS(4) != Z_DEFLATED) {

  0017f	8b c2		 mov	 eax, edx
  00181	24 0f		 and	 al, 15			; 0000000fH
  00183	3c 08		 cmp	 al, 8
  00185	74 16		 je	 SHORT $LN26@inflate
$LN933@inflate:

; 686  :                 strm->msg = (char *)"unknown compression method";

  00187	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0018a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 687  :                 state->mode = BAD;

  00191	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 688  :                 break;

  00198	e9 e0 09 00 00	 jmp	 $LN8@inflate
$LN26@inflate:

; 689  :             }
; 690  :             DROPBITS(4);

  0019d	c1 ea 04	 shr	 edx, 4
  001a0	83 ee 04	 sub	 esi, 4

; 691  :             len = BITS(4) + 8;

  001a3	8b c2		 mov	 eax, edx
  001a5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  001a8	83 e0 0f	 and	 eax, 15			; 0000000fH
  001ab	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  001ae	83 c0 08	 add	 eax, 8

; 692  :             if (state->wbits == 0)

  001b1	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  001b5	89 45 cc	 mov	 DWORD PTR _len$1$[ebp], eax
  001b8	75 03		 jne	 SHORT $LN344@inflate

; 693  :                 state->wbits = len;

  001ba	89 41 28	 mov	 DWORD PTR [ecx+40], eax
$LN344@inflate:

; 694  :             if (len > 15 || len > state->wbits) {

  001bd	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001c0	77 4f		 ja	 SHORT $LN346@inflate
  001c2	3b 41 28	 cmp	 eax, DWORD PTR [ecx+40]
  001c5	77 4a		 ja	 SHORT $LN346@inflate

; 698  :             }
; 699  :             state->dmax = 1U << len;

  001c7	8b 4d cc	 mov	 ecx, DWORD PTR _len$1$[ebp]
  001ca	b8 01 00 00 00	 mov	 eax, 1
  001cf	d3 e0		 shl	 eax, cl
  001d1	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 700  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 701  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001d4	6a 00		 push	 0
  001d6	6a 00		 push	 0
  001d8	6a 00		 push	 0
  001da	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001dd	e8 00 00 00 00	 call	 _adler32@12
  001e2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001e5	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001e8	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  001eb	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 702  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001ee	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001f1	c1 ea 08	 shr	 edx, 8
  001f4	f7 d2		 not	 edx
  001f6	83 e2 02	 and	 edx, 2
  001f9	81 ca 3d 3f 00
	00		 or	 edx, 16189		; 00003f3dH
  001ff	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 703  :             INITBITS();

  00202	33 d2		 xor	 edx, edx
  00204	33 f6		 xor	 esi, esi
  00206	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00209	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 704  :             break;

  0020c	e9 6c 09 00 00	 jmp	 $LN8@inflate
$LN346@inflate:

; 695  :                 strm->msg = (char *)"invalid window size";

  00211	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00214	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 696  :                 state->mode = BAD;

  0021b	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 697  :                 break;

  00222	e9 56 09 00 00	 jmp	 $LN8@inflate
$LN342@inflate:

; 677  : #else
; 678  :             if (
; 679  : #endif
; 680  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 681  :                 strm->msg = (char *)"incorrect header check";

  00227	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0022a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@

; 682  :                 state->mode = BAD;

  00231	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 683  :                 break;

  00238	e9 40 09 00 00	 jmp	 $LN8@inflate
$LN32@inflate:

; 705  : #ifdef GUNZIP
; 706  :         case FLAGS:
; 707  :             NEEDBITS(16);

  0023d	83 fe 10	 cmp	 esi, 16			; 00000010H
  00240	73 2a		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00242	85 db		 test	 ebx, ebx
  00244	0f 84 74 03 00
	00		 je	 $LN887@inflate
  0024a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0024d	8b ce		 mov	 ecx, esi
  0024f	d3 e0		 shl	 eax, cl
  00251	83 c6 08	 add	 esi, 8
  00254	4b		 dec	 ebx
  00255	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00258	03 d0		 add	 edx, eax
  0025a	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0025d	47		 inc	 edi
  0025e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00261	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00264	83 fe 10	 cmp	 esi, 16			; 00000010H
  00267	72 d9		 jb	 SHORT $LL33@inflate
  00269	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN30@inflate:

; 708  :             state->flags = (int)(hold);

  0026c	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  0026f	80 fa 08	 cmp	 dl, 8

; 709  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00272	0f 85 0f ff ff
	ff		 jne	 $LN933@inflate

; 710  :                 strm->msg = (char *)"unknown compression method";
; 711  :                 state->mode = BAD;
; 712  :                 break;
; 713  :             }
; 714  :             if (state->flags & 0xe000) {

  00278	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  0027e	74 16		 je	 SHORT $LN350@inflate

; 715  :                 strm->msg = (char *)"unknown header flags set";

  00280	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00283	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  0028a	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00291	e9 e7 08 00 00	 jmp	 $LN8@inflate
$LN350@inflate:

; 716  :                 state->mode = BAD;
; 717  :                 break;
; 718  :             }
; 719  :             if (state->head != Z_NULL)

  00296	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  00299	85 f6		 test	 esi, esi
  0029b	74 0a		 je	 SHORT $LN351@inflate

; 720  :                 state->head->text = (int)((hold >> 8) & 1);

  0029d	8b c2		 mov	 eax, edx
  0029f	c1 e8 08	 shr	 eax, 8
  002a2	83 e0 01	 and	 eax, 1
  002a5	89 06		 mov	 DWORD PTR [esi], eax
$LN351@inflate:

; 721  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002a7	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  002ae	74 23		 je	 SHORT $LN39@inflate
  002b0	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  002b4	74 1d		 je	 SHORT $LN39@inflate

; 722  :                 CRC2(state->check, hold);

  002b6	6a 02		 push	 2
  002b8	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  002bb	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  002be	50		 push	 eax
  002bf	ff 71 1c	 push	 DWORD PTR [ecx+28]
  002c2	c1 ea 08	 shr	 edx, 8
  002c5	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  002c8	e8 00 00 00 00	 call	 _crc32@12
  002cd	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  002d0	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN39@inflate:

; 723  :             INITBITS();

  002d3	33 d2		 xor	 edx, edx

; 724  :             state->mode = TIME;

  002d5	c7 41 04 36 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16182 ; 00003f36H
  002dc	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  002df	33 f6		 xor	 esi, esi

; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  002e1	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  002e3	83 fe 20	 cmp	 esi, 32			; 00000020H
  002e6	73 27		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  002e8	85 db		 test	 ebx, ebx
  002ea	0f 84 ce 02 00
	00		 je	 $LN887@inflate
  002f0	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  002f3	8b ce		 mov	 ecx, esi
  002f5	d3 e0		 shl	 eax, cl
  002f7	4b		 dec	 ebx
  002f8	03 d0		 add	 edx, eax
  002fa	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  002fd	47		 inc	 edi
  002fe	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00301	83 c6 08	 add	 esi, 8
  00304	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00307	83 fe 20	 cmp	 esi, 32			; 00000020H
  0030a	72 dc		 jb	 SHORT $LL47@inflate
  0030c	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN44@inflate:

; 727  :             if (state->head != Z_NULL)

  0030f	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00312	85 c0		 test	 eax, eax
  00314	74 03		 je	 SHORT $LN355@inflate

; 728  :                 state->head->time = hold;

  00316	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN355@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00319	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00320	74 33		 je	 SHORT $LN53@inflate
  00322	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00326	74 2d		 je	 SHORT $LN53@inflate

; 730  :                 CRC4(state->check, hold);

  00328	8b c2		 mov	 eax, edx
  0032a	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  0032d	c1 e8 08	 shr	 eax, 8
  00330	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  00333	8b c2		 mov	 eax, edx
  00335	c1 e8 10	 shr	 eax, 16			; 00000010H
  00338	88 45 e6	 mov	 BYTE PTR _hbuf$[ebp+2], al
  0033b	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  0033e	6a 04		 push	 4
  00340	50		 push	 eax
  00341	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00344	c1 ea 18	 shr	 edx, 24			; 00000018H
  00347	88 55 e7	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  0034a	e8 00 00 00 00	 call	 _crc32@12
  0034f	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00352	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN53@inflate:

; 731  :             INITBITS();

  00355	33 d2		 xor	 edx, edx

; 732  :             state->mode = OS;

  00357	c7 41 04 37 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16183 ; 00003f37H
  0035e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00361	33 f6		 xor	 esi, esi

; 733  :         case OS:
; 734  :             NEEDBITS(16);

  00363	eb 0b		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  00365	83 fe 10	 cmp	 esi, 16			; 00000010H
  00368	73 2d		 jae	 SHORT $LN58@inflate
  0036a	66 0f 1f 44 00
	00		 npad	 6
$LL61@inflate:
  00370	85 db		 test	 ebx, ebx
  00372	0f 84 46 02 00
	00		 je	 $LN887@inflate
  00378	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0037b	8b ce		 mov	 ecx, esi
  0037d	d3 e0		 shl	 eax, cl
  0037f	4b		 dec	 ebx
  00380	03 d0		 add	 edx, eax
  00382	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00385	47		 inc	 edi
  00386	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00389	83 c6 08	 add	 esi, 8
  0038c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0038f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00392	72 dc		 jb	 SHORT $LL61@inflate
  00394	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN58@inflate:

; 735  :             if (state->head != Z_NULL) {

  00397	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  0039a	85 f6		 test	 esi, esi
  0039c	74 17		 je	 SHORT $LN359@inflate

; 736  :                 state->head->xflags = (int)(hold & 0xff);

  0039e	0f b6 c2	 movzx	 eax, dl

; 737  :                 state->head->os = (int)(hold >> 8);

  003a1	8b ca		 mov	 ecx, edx
  003a3	89 46 08	 mov	 DWORD PTR [esi+8], eax
  003a6	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  003a9	c1 e9 08	 shr	 ecx, 8
  003ac	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  003af	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  003b2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN359@inflate:

; 738  :             }
; 739  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  003b5	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  003bc	74 23		 je	 SHORT $LN67@inflate
  003be	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  003c2	74 1d		 je	 SHORT $LN67@inflate

; 740  :                 CRC2(state->check, hold);

  003c4	6a 02		 push	 2
  003c6	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  003c9	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  003cc	50		 push	 eax
  003cd	ff 71 1c	 push	 DWORD PTR [ecx+28]
  003d0	c1 ea 08	 shr	 edx, 8
  003d3	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  003d6	e8 00 00 00 00	 call	 _crc32@12
  003db	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003de	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN67@inflate:

; 741  :             INITBITS();

  003e1	33 d2		 xor	 edx, edx

; 742  :             state->mode = EXLEN;

  003e3	c7 41 04 38 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16184 ; 00003f38H
  003ea	33 f6		 xor	 esi, esi
  003ec	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  003ef	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN361@inflate:

; 743  :         case EXLEN:
; 744  :             if (state->flags & 0x0400) {

  003f2	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  003f9	74 73		 je	 SHORT $LN362@inflate

; 745  :                 NEEDBITS(16);

  003fb	83 fe 10	 cmp	 esi, 16			; 00000010H
  003fe	73 27		 jae	 SHORT $LN72@inflate
$LL75@inflate:
  00400	85 db		 test	 ebx, ebx
  00402	0f 84 b6 01 00
	00		 je	 $LN887@inflate
  00408	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0040b	8b ce		 mov	 ecx, esi
  0040d	d3 e0		 shl	 eax, cl
  0040f	4b		 dec	 ebx
  00410	03 d0		 add	 edx, eax
  00412	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00415	47		 inc	 edi
  00416	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00419	83 c6 08	 add	 esi, 8
  0041c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0041f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00422	72 dc		 jb	 SHORT $LL75@inflate
  00424	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN72@inflate:

; 746  :                 state->length = (unsigned)(hold);
; 747  :                 if (state->head != Z_NULL)

  00427	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0042a	89 51 44	 mov	 DWORD PTR [ecx+68], edx
  0042d	85 c0		 test	 eax, eax
  0042f	74 03		 je	 SHORT $LN365@inflate

; 748  :                     state->head->extra_len = (unsigned)hold;

  00431	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN365@inflate:

; 749  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00434	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  0043b	74 23		 je	 SHORT $LN81@inflate
  0043d	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00441	74 1d		 je	 SHORT $LN81@inflate

; 750  :                     CRC2(state->check, hold);

  00443	6a 02		 push	 2
  00445	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00448	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  0044b	50		 push	 eax
  0044c	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0044f	c1 ea 08	 shr	 edx, 8
  00452	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00455	e8 00 00 00 00	 call	 _crc32@12
  0045a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0045d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN81@inflate:

; 751  :                 INITBITS();

  00460	33 f6		 xor	 esi, esi
  00462	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00469	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 752  :             }

  0046c	eb 0e		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 753  :             else if (state->head != Z_NULL)

  0046e	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00471	85 c0		 test	 eax, eax
  00473	74 07		 je	 SHORT $LN367@inflate

; 754  :                 state->head->extra = Z_NULL;

  00475	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN367@inflate:

; 755  :             state->mode = EXTRA;

  0047c	c7 41 04 39 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16185 ; 00003f39H
$LN368@inflate:

; 756  :         case EXTRA:
; 757  :             if (state->flags & 0x0400) {

  00483	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  0048a	0f 84 93 00 00
	00		 je	 $LN374@inflate

; 758  :                 copy = state->length;

  00490	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 759  :                 if (copy > have) copy = have;

  00493	3b c3		 cmp	 eax, ebx
  00495	8b d0		 mov	 edx, eax
  00497	89 45 d8	 mov	 DWORD PTR _copy$1$[ebp], eax
  0049a	0f 47 d3	 cmova	 edx, ebx
  0049d	89 55 cc	 mov	 DWORD PTR _copy$2$[ebp], edx

; 760  :                 if (copy) {

  004a0	85 d2		 test	 edx, edx
  004a2	74 75		 je	 SHORT $LN371@inflate

; 761  :                     if (state->head != Z_NULL &&

  004a4	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  004a7	85 c0		 test	 eax, eax
  004a9	74 3f		 je	 SHORT $LN372@inflate
  004ab	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  004ae	85 ff		 test	 edi, edi
  004b0	89 7d f4	 mov	 DWORD PTR tv2764[ebp], edi
  004b3	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  004b6	74 32		 je	 SHORT $LN372@inflate

; 762  :                         state->head->extra != Z_NULL) {
; 763  :                         len = state->head->extra_len - state->length;

  004b8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  004bb	2b 4d d8	 sub	 ecx, DWORD PTR _copy$1$[ebp]
  004be	89 4d d8	 mov	 DWORD PTR _len$2$[ebp], ecx

; 764  :                         zmemcpy(state->head->extra + len, next,

  004c1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  004c4	8b 45 d8	 mov	 eax, DWORD PTR _len$2$[ebp]
  004c7	03 c2		 add	 eax, edx
  004c9	3b c1		 cmp	 eax, ecx
  004cb	8b 45 d8	 mov	 eax, DWORD PTR _len$2$[ebp]
  004ce	76 04		 jbe	 SHORT $LN509@inflate
  004d0	2b c8		 sub	 ecx, eax
  004d2	eb 02		 jmp	 SHORT $LN510@inflate
$LN509@inflate:
  004d4	8b ca		 mov	 ecx, edx
$LN510@inflate:
  004d6	03 45 f4	 add	 eax, DWORD PTR tv2764[ebp]
  004d9	51		 push	 ecx
  004da	57		 push	 edi
  004db	50		 push	 eax
  004dc	e8 00 00 00 00	 call	 _memcpy
  004e1	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  004e7	8b 55 cc	 mov	 edx, DWORD PTR _copy$2$[ebp]
$LN372@inflate:

; 765  :                                 len + copy > state->head->extra_max ?
; 766  :                                 state->head->extra_max - len : copy);
; 767  :                     }
; 768  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  004ea	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  004f1	74 16		 je	 SHORT $LN373@inflate
  004f3	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  004f7	74 10		 je	 SHORT $LN373@inflate

; 769  :                         state->check = crc32(state->check, next, copy);

  004f9	52		 push	 edx
  004fa	57		 push	 edi
  004fb	ff 71 1c	 push	 DWORD PTR [ecx+28]
  004fe	e8 00 00 00 00	 call	 _crc32@12
  00503	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00506	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN373@inflate:

; 770  :                     have -= copy;

  00509	8b 45 cc	 mov	 eax, DWORD PTR _copy$2$[ebp]
  0050c	2b d8		 sub	 ebx, eax

; 771  :                     next += copy;

  0050e	03 f8		 add	 edi, eax
  00510	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx

; 772  :                     state->length -= copy;

  00513	29 41 44	 sub	 DWORD PTR [ecx+68], eax
  00516	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
$LN371@inflate:

; 773  :                 }
; 774  :                 if (state->length) goto inf_leave;

  00519	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  0051d	0f 85 9b 00 00
	00		 jne	 $LN887@inflate
$LN374@inflate:

; 775  :             }
; 776  :             state->length = 0;

  00523	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 777  :             state->mode = NAME;

  0052a	c7 41 04 3a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16186 ; 00003f3aH
$LN375@inflate:

; 778  :         case NAME:
; 779  :             if (state->flags & 0x0800) {

  00531	f7 41 14 00 08
	00 00		 test	 DWORD PTR [ecx+20], 2048 ; 00000800H
  00538	0f 84 09 01 00
	00		 je	 $LN376@inflate

; 780  :                 if (have == 0) goto inf_leave;

  0053e	85 db		 test	 ebx, ebx
  00540	74 7c		 je	 SHORT $LN887@inflate

; 781  :                 copy = 0;

  00542	33 d2		 xor	 edx, edx
$LL88@inflate:

; 782  :                 do {
; 783  :                     len = (unsigned)(next[copy++]);

  00544	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  00548	42		 inc	 edx
  00549	89 45 d8	 mov	 DWORD PTR _len$3$[ebp], eax

; 784  :                     if (state->head != Z_NULL &&
; 785  :                             state->head->name != Z_NULL &&

  0054c	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0054f	85 c0		 test	 eax, eax
  00551	74 23		 je	 SHORT $LN86@inflate
  00553	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00556	89 75 f0	 mov	 DWORD PTR tv2761[ebp], esi
  00559	85 f6		 test	 esi, esi
  0055b	74 19		 je	 SHORT $LN86@inflate
  0055d	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  00560	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  00563	73 11		 jae	 SHORT $LN86@inflate

; 786  :                             state->length < state->head->name_max)
; 787  :                         state->head->name[state->length++] = (Bytef)len;

  00565	8b 5d d8	 mov	 ebx, DWORD PTR _len$3$[ebp]
  00568	8b c6		 mov	 eax, esi
  0056a	8b 75 f0	 mov	 esi, DWORD PTR tv2761[ebp]
  0056d	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  00570	ff 41 44	 inc	 DWORD PTR [ecx+68]
  00573	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN86@inflate:

; 788  :                 } while (len && copy < have);

  00576	8b 45 d8	 mov	 eax, DWORD PTR _len$3$[ebp]
  00579	85 c0		 test	 eax, eax
  0057b	74 04		 je	 SHORT $LN380@inflate
  0057d	3b d3		 cmp	 edx, ebx
  0057f	72 c3		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 789  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00581	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00588	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  0058b	89 55 cc	 mov	 DWORD PTR _copy$3$[ebp], edx
  0058e	74 1c		 je	 SHORT $LN381@inflate
  00590	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00594	74 16		 je	 SHORT $LN381@inflate

; 790  :                     state->check = crc32(state->check, next, copy);

  00596	52		 push	 edx
  00597	57		 push	 edi
  00598	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0059b	e8 00 00 00 00	 call	 _crc32@12
  005a0	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  005a3	8b 55 cc	 mov	 edx, DWORD PTR _copy$3$[ebp]
  005a6	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  005a9	8b 45 d8	 mov	 eax, DWORD PTR _len$3$[ebp]
$LN381@inflate:

; 791  :                 have -= copy;

  005ac	2b da		 sub	 ebx, edx

; 792  :                 next += copy;

  005ae	03 fa		 add	 edi, edx
  005b0	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  005b3	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 793  :                 if (len) goto inf_leave;

  005b6	85 c0		 test	 eax, eax
  005b8	0f 84 97 00 00
	00		 je	 $LN383@inflate
$LN887@inflate:
  005be	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
$LN896@inflate:
  005c1	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
$inf_leave$938:

; 1245 :         }
; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  005c4	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  005c7	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  005ca	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  005cd	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  005d0	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  005d3	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  005d6	8b 4d f0	 mov	 ecx, DWORD PTR _next$1$[ebp]
  005d9	89 47 04	 mov	 DWORD PTR [edi+4], eax
  005dc	8b 45 fc	 mov	 eax, DWORD PTR _hold$1$[ebp]
  005df	89 0f		 mov	 DWORD PTR [edi], ecx

; 1255 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  005e1	83 7b 2c 00	 cmp	 DWORD PTR [ebx+44], 0
  005e5	89 73 40	 mov	 DWORD PTR [ebx+64], esi
  005e8	8b 75 dc	 mov	 esi, DWORD PTR _out$1$[ebp]
  005eb	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  005ee	75 27		 jne	 SHORT $LN502@inflate
  005f0	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  005f3	0f 84 0f 10 00
	00		 je	 $LN503@inflate
  005f9	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  005fc	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  00601	0f 8d 01 10 00
	00		 jge	 $LN503@inflate
  00607	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  0060c	7c 09		 jl	 SHORT $LN502@inflate
  0060e	83 fa 04	 cmp	 edx, 4
  00611	0f 84 f1 0f 00
	00		 je	 $LN503@inflate
$LN502@inflate:

; 1256 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1257 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  00617	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  0061a	8b c6		 mov	 eax, esi
  0061c	2b 47 10	 sub	 eax, DWORD PTR [edi+16]
  0061f	8b cf		 mov	 ecx, edi
  00621	50		 push	 eax
  00622	e8 00 00 00 00	 call	 _updatewindow
  00627	83 c4 04	 add	 esp, 4
  0062a	85 c0		 test	 eax, eax
  0062c	0f 84 d6 0f 00
	00		 je	 $LN503@inflate

; 1258 :             state->mode = MEM;

  00632	c7 43 04 52 3f
	00 00		 mov	 DWORD PTR [ebx+4], 16210 ; 00003f52H
$LN498@inflate:
  00639	5f		 pop	 edi
  0063a	5e		 pop	 esi

; 1259 :             return Z_MEM_ERROR;

  0063b	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00640	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  00641	8b e5		 mov	 esp, ebp
  00643	5d		 pop	 ebp
  00644	c2 08 00	 ret	 8
$LN376@inflate:

; 794  :             }
; 795  :             else if (state->head != Z_NULL)

  00647	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0064a	85 c0		 test	 eax, eax
  0064c	74 07		 je	 SHORT $LN383@inflate

; 796  :                 state->head->name = Z_NULL;

  0064e	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN383@inflate:

; 797  :             state->length = 0;

  00655	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 798  :             state->mode = COMMENT;

  0065c	c7 41 04 3b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16187 ; 00003f3bH
$LN384@inflate:

; 799  :         case COMMENT:
; 800  :             if (state->flags & 0x1000) {

  00663	f7 41 14 00 10
	00 00		 test	 DWORD PTR [ecx+20], 4096 ; 00001000H
  0066a	0f 84 8c 00 00
	00		 je	 $LN385@inflate

; 801  :                 if (have == 0) goto inf_leave;

  00670	85 db		 test	 ebx, ebx
  00672	0f 84 46 ff ff
	ff		 je	 $LN887@inflate

; 802  :                 copy = 0;

  00678	33 d2		 xor	 edx, edx
  0067a	66 0f 1f 44 00
	00		 npad	 6
$LL91@inflate:

; 803  :                 do {
; 804  :                     len = (unsigned)(next[copy++]);

  00680	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  00684	42		 inc	 edx
  00685	89 45 d8	 mov	 DWORD PTR _len$4$[ebp], eax

; 805  :                     if (state->head != Z_NULL &&
; 806  :                             state->head->comment != Z_NULL &&

  00688	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0068b	85 c0		 test	 eax, eax
  0068d	74 23		 je	 SHORT $LN89@inflate
  0068f	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  00692	89 75 f0	 mov	 DWORD PTR tv2760[ebp], esi
  00695	85 f6		 test	 esi, esi
  00697	74 19		 je	 SHORT $LN89@inflate
  00699	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  0069c	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  0069f	73 11		 jae	 SHORT $LN89@inflate

; 807  :                             state->length < state->head->comm_max)
; 808  :                         state->head->comment[state->length++] = (Bytef)len;

  006a1	8b 5d d8	 mov	 ebx, DWORD PTR _len$4$[ebp]
  006a4	8b c6		 mov	 eax, esi
  006a6	8b 75 f0	 mov	 esi, DWORD PTR tv2760[ebp]
  006a9	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  006ac	ff 41 44	 inc	 DWORD PTR [ecx+68]
  006af	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN89@inflate:

; 809  :                 } while (len && copy < have);

  006b2	8b 45 d8	 mov	 eax, DWORD PTR _len$4$[ebp]
  006b5	85 c0		 test	 eax, eax
  006b7	74 04		 je	 SHORT $LN389@inflate
  006b9	3b d3		 cmp	 edx, ebx
  006bb	72 c3		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 810  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  006bd	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  006c4	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  006c7	89 55 cc	 mov	 DWORD PTR _copy$4$[ebp], edx
  006ca	74 1c		 je	 SHORT $LN390@inflate
  006cc	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  006d0	74 16		 je	 SHORT $LN390@inflate

; 811  :                     state->check = crc32(state->check, next, copy);

  006d2	52		 push	 edx
  006d3	57		 push	 edi
  006d4	ff 71 1c	 push	 DWORD PTR [ecx+28]
  006d7	e8 00 00 00 00	 call	 _crc32@12
  006dc	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  006df	8b 55 cc	 mov	 edx, DWORD PTR _copy$4$[ebp]
  006e2	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  006e5	8b 45 d8	 mov	 eax, DWORD PTR _len$4$[ebp]
$LN390@inflate:

; 812  :                 have -= copy;

  006e8	2b da		 sub	 ebx, edx

; 813  :                 next += copy;

  006ea	03 fa		 add	 edi, edx
  006ec	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  006ef	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 814  :                 if (len) goto inf_leave;

  006f2	85 c0		 test	 eax, eax
  006f4	0f 85 c4 fe ff
	ff		 jne	 $LN887@inflate

; 815  :             }

  006fa	eb 0e		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 816  :             else if (state->head != Z_NULL)

  006fc	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  006ff	85 c0		 test	 eax, eax
  00701	74 07		 je	 SHORT $LN392@inflate

; 817  :                 state->head->comment = Z_NULL;

  00703	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN392@inflate:
  0070a	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 818  :             state->mode = HCRC;

  0070d	c7 41 04 3c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16188 ; 00003f3cH
$LN393@inflate:

; 819  :         case HCRC:
; 820  :             if (state->flags & 0x0200) {

  00714	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  0071b	74 5f		 je	 SHORT $LN101@inflate

; 821  :                 NEEDBITS(16);

  0071d	83 fe 10	 cmp	 esi, 16			; 00000010H
  00720	73 2a		 jae	 SHORT $LN92@inflate
$LL95@inflate:
  00722	85 db		 test	 ebx, ebx
  00724	0f 84 94 fe ff
	ff		 je	 $LN887@inflate
  0072a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0072d	8b ce		 mov	 ecx, esi
  0072f	d3 e0		 shl	 eax, cl
  00731	83 c6 08	 add	 esi, 8
  00734	4b		 dec	 ebx
  00735	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00738	03 d0		 add	 edx, eax
  0073a	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0073d	47		 inc	 edi
  0073e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00741	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00744	83 fe 10	 cmp	 esi, 16			; 00000010H
  00747	72 d9		 jb	 SHORT $LL95@inflate
  00749	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN92@inflate:

; 822  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  0074c	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00750	74 1e		 je	 SHORT $LN102@inflate
  00752	0f b7 41 1c	 movzx	 eax, WORD PTR [ecx+28]
  00756	3b d0		 cmp	 edx, eax
  00758	74 16		 je	 SHORT $LN102@inflate

; 823  :                     strm->msg = (char *)"header crc mismatch";

  0075a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0075d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
  00764	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  0076b	e9 0d 04 00 00	 jmp	 $LN8@inflate
$LN102@inflate:

; 824  :                     state->mode = BAD;
; 825  :                     break;
; 826  :                 }
; 827  :                 INITBITS();

  00770	33 f6		 xor	 esi, esi
  00772	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00779	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN101@inflate:

; 828  :             }
; 829  :             if (state->head != Z_NULL) {

  0077c	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0077f	85 d2		 test	 edx, edx
  00781	74 16		 je	 SHORT $LN397@inflate

; 830  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00783	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00786	c1 f8 09	 sar	 eax, 9
  00789	83 e0 01	 and	 eax, 1
  0078c	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 831  :                 state->head->done = 1;

  0078f	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00792	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN397@inflate:

; 832  :             }
; 833  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00799	6a 00		 push	 0
  0079b	6a 00		 push	 0
  0079d	6a 00		 push	 0
  0079f	e8 00 00 00 00	 call	 _crc32@12
  007a4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007a7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007aa	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  007ad	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 834  :             state->mode = TYPE;

  007b0	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 835  :             break;

  007b7	e9 be 03 00 00	 jmp	 $LN888@inflate
$LN105@inflate:

; 836  : #endif
; 837  :         case DICTID:
; 838  :             NEEDBITS(32);

  007bc	83 fe 20	 cmp	 esi, 32			; 00000020H
  007bf	73 24		 jae	 SHORT $LN103@inflate
$LL106@inflate:
  007c1	85 db		 test	 ebx, ebx
  007c3	0f 84 f5 fd ff
	ff		 je	 $LN887@inflate
  007c9	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  007cc	8b ce		 mov	 ecx, esi
  007ce	d3 e0		 shl	 eax, cl
  007d0	4b		 dec	 ebx
  007d1	03 d0		 add	 edx, eax
  007d3	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  007d6	47		 inc	 edi
  007d7	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  007da	83 c6 08	 add	 esi, 8
  007dd	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  007e0	83 fe 20	 cmp	 esi, 32			; 00000020H
  007e3	72 dc		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 839  :             strm->adler = state->check = ZSWAP32(hold);

  007e5	8b ca		 mov	 ecx, edx
  007e7	8b c2		 mov	 eax, edx
  007e9	c1 e0 10	 shl	 eax, 16			; 00000010H
  007ec	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007f2	03 c8		 add	 ecx, eax
  007f4	8b c2		 mov	 eax, edx
  007f6	c1 e8 08	 shr	 eax, 8
  007f9	c1 e1 08	 shl	 ecx, 8
  007fc	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00801	c1 ea 18	 shr	 edx, 24			; 00000018H
  00804	03 c1		 add	 eax, ecx
  00806	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00809	03 c2		 add	 eax, edx
  0080b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0080e	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00811	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 840  :             INITBITS();

  00814	33 d2		 xor	 edx, edx
  00816	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00819	33 f6		 xor	 esi, esi

; 841  :             state->mode = DICT;

  0081b	c7 41 04 3e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16190 ; 00003f3eH
$LN400@inflate:

; 842  :         case DICT:
; 843  :             if (state->havedict == 0) {

  00822	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00826	0f 84 81 0d 00
	00		 je	 $LN586@inflate

; 846  :             }
; 847  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  0082c	6a 00		 push	 0
  0082e	6a 00		 push	 0
  00830	6a 00		 push	 0
  00832	e8 00 00 00 00	 call	 _adler32@12
  00837	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0083a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0083d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00840	89 42 30	 mov	 DWORD PTR [edx+48], eax
  00843	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 848  :             state->mode = TYPE;

  00846	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
$LN402@inflate:

; 849  :         case TYPE:
; 850  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  0084d	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  00850	83 f8 05	 cmp	 eax, 5
  00853	0f 84 65 fd ff
	ff		 je	 $LN887@inflate
  00859	83 f8 06	 cmp	 eax, 6
  0085c	0f 84 5c fd ff
	ff		 je	 $LN887@inflate
$LN403@inflate:

; 851  :         case TYPEDO:
; 852  :             if (state->last) {

  00862	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00866	74 1e		 je	 SHORT $LN122@inflate

; 853  :                 BYTEBITS();

  00868	8b ce		 mov	 ecx, esi
  0086a	83 e1 07	 and	 ecx, 7
  0086d	d3 ea		 shr	 edx, cl
  0086f	2b f1		 sub	 esi, ecx

; 854  :                 state->mode = CHECK;

  00871	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00874	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00877	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0087a	c7 41 04 4e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16206 ; 00003f4eH

; 855  :                 break;

  00881	e9 f7 02 00 00	 jmp	 $LN8@inflate
$LN122@inflate:

; 856  :             }
; 857  :             NEEDBITS(3);

  00886	83 fe 03	 cmp	 esi, 3
  00889	73 2c		 jae	 SHORT $LN120@inflate
  0088b	0f 1f 44 00 00	 npad	 5
$LL123@inflate:
  00890	85 db		 test	 ebx, ebx
  00892	0f 84 26 fd ff
	ff		 je	 $LN887@inflate
  00898	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0089b	8b ce		 mov	 ecx, esi
  0089d	d3 e0		 shl	 eax, cl
  0089f	4b		 dec	 ebx
  008a0	03 d0		 add	 edx, eax
  008a2	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  008a5	47		 inc	 edi
  008a6	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008a9	83 c6 08	 add	 esi, 8
  008ac	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  008af	83 fe 03	 cmp	 esi, 3
  008b2	72 dc		 jb	 SHORT $LL123@inflate
  008b4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN120@inflate:

; 858  :             state->last = BITS(1);

  008b7	8b c2		 mov	 eax, edx

; 859  :             DROPBITS(1);

  008b9	d1 ea		 shr	 edx, 1
  008bb	83 e0 01	 and	 eax, 1
  008be	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 860  :             switch (BITS(2)) {

  008c1	8b c2		 mov	 eax, edx
  008c3	83 e0 03	 and	 eax, 3
  008c6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN937@inflate[eax*4]
$LN408@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  008cd	c1 ea 02	 shr	 edx, 2
  008d0	83 ee 03	 sub	 esi, 3
  008d3	c7 41 04 41 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16193 ; 00003f41H
  008da	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008dd	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  008e0	e9 98 02 00 00	 jmp	 $LN8@inflate
$LN409@inflate:

; 861  :             case 0:                             /* stored block */
; 862  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 863  :                         state->last ? " (last)" : ""));
; 864  :                 state->mode = STORED;
; 865  :                 break;
; 866  :             case 1:                             /* fixed block */
; 867  :                 fixedtables(state);

  008e5	e8 00 00 00 00	 call	 _fixedtables

; 868  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 869  :                         state->last ? " (last)" : ""));
; 870  :                 state->mode = LEN_;             /* decode codes */
; 871  :                 if (flush == Z_TREES) {

  008ea	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  008ee	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  008f5	75 37		 jne	 SHORT $LN138@inflate

; 872  :                     DROPBITS(2);

  008f7	c1 ea 02	 shr	 edx, 2
  008fa	83 ee 03	 sub	 esi, 3
  008fd	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 873  :                     goto inf_leave;

  00900	e9 b9 fc ff ff	 jmp	 $LN887@inflate
$LN411@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  00905	c1 ea 02	 shr	 edx, 2
  00908	83 ee 03	 sub	 esi, 3
  0090b	c7 41 04 44 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16196 ; 00003f44H
  00912	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00915	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  00918	e9 60 02 00 00	 jmp	 $LN8@inflate
$LN412@inflate:

; 874  :                 }
; 875  :                 break;
; 876  :             case 2:                             /* dynamic block */
; 877  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = TABLE;
; 880  :                 break;
; 881  :             case 3:
; 882  :                 strm->msg = (char *)"invalid block type";

  0091d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00920	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 883  :                 state->mode = BAD;

  00927	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN138@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  0092e	c1 ea 02	 shr	 edx, 2
  00931	83 ee 03	 sub	 esi, 3
  00934	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00937	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  0093a	e9 3e 02 00 00	 jmp	 $LN8@inflate
$LN141@inflate:

; 887  :         case STORED:
; 888  :             BYTEBITS();                         /* go to byte boundary */

  0093f	8b ce		 mov	 ecx, esi
  00941	83 e1 07	 and	 ecx, 7
  00944	2b f1		 sub	 esi, ecx
  00946	d3 ea		 shr	 edx, cl
  00948	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0094b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 889  :             NEEDBITS(32);

  0094e	83 fe 20	 cmp	 esi, 32			; 00000020H
  00951	73 27		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  00953	85 db		 test	 ebx, ebx
  00955	0f 84 63 fc ff
	ff		 je	 $LN887@inflate
  0095b	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0095e	8b ce		 mov	 ecx, esi
  00960	d3 e0		 shl	 eax, cl
  00962	83 c6 08	 add	 esi, 8
  00965	4b		 dec	 ebx
  00966	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00969	03 d0		 add	 edx, eax
  0096b	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0096e	47		 inc	 edi
  0096f	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00972	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00975	83 fe 20	 cmp	 esi, 32			; 00000020H
  00978	72 d9		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 890  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  0097a	8b c2		 mov	 eax, edx
  0097c	0f b7 ca	 movzx	 ecx, dx
  0097f	f7 d0		 not	 eax
  00981	89 4d cc	 mov	 DWORD PTR tv2753[ebp], ecx
  00984	c1 e8 10	 shr	 eax, 16			; 00000010H
  00987	3b c8		 cmp	 ecx, eax

; 892  :                 state->mode = BAD;

  00989	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0098c	74 16		 je	 SHORT $LN415@inflate

; 891  :                 strm->msg = (char *)"invalid stored block lengths";

  0098e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00991	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  00998	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  0099f	e9 d9 01 00 00	 jmp	 $LN8@inflate
$LN415@inflate:

; 893  :                 break;
; 894  :             }
; 895  :             state->length = (unsigned)hold & 0xffff;

  009a4	8b 45 cc	 mov	 eax, DWORD PTR tv2753[ebp]

; 896  :             Tracev((stderr, "inflate:       stored length %u\n",
; 897  :                     state->length));
; 898  :             INITBITS();

  009a7	33 d2		 xor	 edx, edx
  009a9	33 f6		 xor	 esi, esi
  009ab	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 899  :             state->mode = COPY_;
; 900  :             if (flush == Z_TREES) goto inf_leave;

  009ae	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  009b2	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  009b5	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  009b8	c7 41 04 42 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16194 ; 00003f42H
  009bf	0f 84 f9 fb ff
	ff		 je	 $LN887@inflate
$LN416@inflate:

; 901  :         case COPY_:
; 902  :             state->mode = COPY;

  009c5	c7 41 04 43 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16195 ; 00003f43H
$LN418@inflate:

; 903  :         case COPY:
; 904  :             copy = state->length;

  009cc	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 905  :             if (copy) {

  009cf	85 c0		 test	 eax, eax
  009d1	0f 84 fe 06 00
	00		 je	 $LN419@inflate

; 906  :                 if (copy > have) copy = have;

  009d7	3b c3		 cmp	 eax, ebx
  009d9	0f 47 c3	 cmova	 eax, ebx

; 907  :                 if (copy > left) copy = left;

  009dc	3b 45 e8	 cmp	 eax, DWORD PTR _left$1$[ebp]
  009df	0f 47 45 e8	 cmova	 eax, DWORD PTR _left$1$[ebp]
  009e3	89 45 cc	 mov	 DWORD PTR _copy$7$[ebp], eax

; 908  :                 if (copy == 0) goto inf_leave;

  009e6	85 c0		 test	 eax, eax
  009e8	0f 84 d0 fb ff
	ff		 je	 $LN887@inflate

; 909  :                 zmemcpy(put, next, copy);

  009ee	50		 push	 eax
  009ef	57		 push	 edi
  009f0	ff 75 e0	 push	 DWORD PTR _put$1$[ebp]
  009f3	e8 00 00 00 00	 call	 _memcpy

; 910  :                 have -= copy;

  009f8	8b 45 cc	 mov	 eax, DWORD PTR _copy$7$[ebp]
  009fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 911  :                 next += copy;
; 912  :                 left -= copy;
; 913  :                 put += copy;
; 914  :                 state->length -= copy;

  009fe	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00a01	2b d8		 sub	 ebx, eax
  00a03	29 45 e8	 sub	 DWORD PTR _left$1$[ebp], eax
  00a06	03 f8		 add	 edi, eax
  00a08	01 45 e0	 add	 DWORD PTR _put$1$[ebp], eax
  00a0b	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a0e	29 41 44	 sub	 DWORD PTR [ecx+68], eax
  00a11	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 915  :                 break;

  00a14	e9 61 01 00 00	 jmp	 $LN888@inflate
$LN155@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       stored end\n"));
; 918  :             state->mode = TYPE;
; 919  :             break;
; 920  :         case TABLE:
; 921  :             NEEDBITS(14);

  00a19	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a1c	73 29		 jae	 SHORT $LN153@inflate
  00a1e	66 90		 npad	 2
$LL156@inflate:
  00a20	85 db		 test	 ebx, ebx
  00a22	0f 84 96 fb ff
	ff		 je	 $LN887@inflate
  00a28	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00a2b	8b ce		 mov	 ecx, esi
  00a2d	d3 e0		 shl	 eax, cl
  00a2f	4b		 dec	 ebx
  00a30	03 d0		 add	 edx, eax
  00a32	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a35	47		 inc	 edi
  00a36	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a39	83 c6 08	 add	 esi, 8
  00a3c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00a3f	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a42	72 dc		 jb	 SHORT $LL156@inflate
  00a44	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN153@inflate:

; 922  :             state->nlen = BITS(5) + 257;

  00a47	8b c2		 mov	 eax, edx

; 923  :             DROPBITS(5);
; 924  :             state->ndist = BITS(5) + 1;
; 925  :             DROPBITS(5);
; 926  :             state->ncode = BITS(4) + 4;
; 927  :             DROPBITS(4);

  00a49	83 ee 0e	 sub	 esi, 14			; 0000000eH
  00a4c	83 e0 1f	 and	 eax, 31			; 0000001fH
  00a4f	c1 ea 05	 shr	 edx, 5
  00a52	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00a57	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a5a	89 41 64	 mov	 DWORD PTR [ecx+100], eax
  00a5d	8b c2		 mov	 eax, edx
  00a5f	83 e0 1f	 and	 eax, 31			; 0000001fH
  00a62	c1 ea 05	 shr	 edx, 5
  00a65	40		 inc	 eax
  00a66	89 41 68	 mov	 DWORD PTR [ecx+104], eax
  00a69	8b c2		 mov	 eax, edx
  00a6b	83 e0 0f	 and	 eax, 15			; 0000000fH
  00a6e	c1 ea 04	 shr	 edx, 4
  00a71	83 c0 04	 add	 eax, 4
  00a74	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 928  : #ifndef PKZIP_BUG_WORKAROUND
; 929  :             if (state->nlen > 286 || state->ndist > 30) {

  00a77	81 79 64 1e 01
	00 00		 cmp	 DWORD PTR [ecx+100], 286 ; 0000011eH
  00a7e	89 41 60	 mov	 DWORD PTR [ecx+96], eax
  00a81	0f 87 15 01 00
	00		 ja	 $LN426@inflate
  00a87	83 79 68 1e	 cmp	 DWORD PTR [ecx+104], 30	; 0000001eH
  00a8b	0f 87 0b 01 00
	00		 ja	 $LN426@inflate

; 931  :                 state->mode = BAD;
; 932  :                 break;
; 933  :             }
; 934  : #endif
; 935  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 936  :             state->have = 0;

  00a91	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 937  :             state->mode = LENLENS;

  00a98	c7 41 04 45 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16197 ; 00003f45H
$LN532@inflate:

; 938  :         case LENLENS:
; 939  :             while (state->have < state->ncode) {

  00a9f	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00aa2	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00aa5	73 64		 jae	 SHORT $LN534@inflate
$LL170@inflate:

; 940  :                 NEEDBITS(3);

  00aa7	83 fe 03	 cmp	 esi, 3
  00aaa	73 28		 jae	 SHORT $LN172@inflate
  00aac	0f 1f 40 00	 npad	 4
$LL175@inflate:
  00ab0	85 db		 test	 ebx, ebx
  00ab2	0f 84 06 fb ff
	ff		 je	 $LN887@inflate
  00ab8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00abb	8b ce		 mov	 ecx, esi
  00abd	d3 e0		 shl	 eax, cl
  00abf	4b		 dec	 ebx
  00ac0	03 d0		 add	 edx, eax
  00ac2	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00ac5	47		 inc	 edi
  00ac6	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ac9	83 c6 08	 add	 esi, 8
  00acc	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00acf	83 fe 03	 cmp	 esi, 3
  00ad2	72 dc		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 941  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00ad4	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00ad7	8b ca		 mov	 ecx, edx
  00ad9	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00adc	83 e1 07	 and	 ecx, 7

; 942  :                 DROPBITS(3);

  00adf	c1 ea 03	 shr	 edx, 3
  00ae2	83 ee 03	 sub	 esi, 3
  00ae5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ae8	8b 40 6c	 mov	 eax, DWORD PTR [eax+108]
  00aeb	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00aee	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00af6	66 89 4c 47 74	 mov	 WORD PTR [edi+eax*2+116], cx
  00afb	8b cf		 mov	 ecx, edi
  00afd	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00b00	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00b03	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00b06	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00b09	72 9c		 jb	 SHORT $LL170@inflate
$LN534@inflate:

; 943  :             }
; 944  :             while (state->have < 19)

  00b0b	83 79 6c 13	 cmp	 DWORD PTR [ecx+108], 19	; 00000013H
  00b0f	73 1b		 jae	 SHORT $LN184@inflate
$LL183@inflate:

; 945  :                 state->lens[order[state->have++]] = 0;

  00b11	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00b14	33 d2		 xor	 edx, edx
  00b16	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00b1e	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00b23	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00b26	83 79 6c 13	 cmp	 DWORD PTR [ecx+108], 19	; 00000013H
  00b2a	72 e5		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 946  :             state->next = state->codes;
; 947  :             state->lencode = (const code FAR *)(state->next);

  00b2c	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00b2f	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  00b35	83 c1 70	 add	 ecx, 112		; 00000070H
  00b38	89 42 50	 mov	 DWORD PTR [edx+80], eax
  00b3b	89 01		 mov	 DWORD PTR [ecx], eax

; 948  :             state->lenbits = 7;
; 949  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00b3d	8d 82 f4 02 00
	00		 lea	 eax, DWORD PTR [edx+756]
  00b43	50		 push	 eax
  00b44	8d 42 58	 lea	 eax, DWORD PTR [edx+88]
  00b47	c7 42 58 07 00
	00 00		 mov	 DWORD PTR [edx+88], 7
  00b4e	50		 push	 eax
  00b4f	51		 push	 ecx
  00b50	6a 13		 push	 19			; 00000013H
  00b52	83 c2 74	 add	 edx, 116		; 00000074H
  00b55	33 c9		 xor	 ecx, ecx
  00b57	e8 00 00 00 00	 call	 _inflate_table

; 953  :                 state->mode = BAD;

  00b5c	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00b5f	83 c4 10	 add	 esp, 16			; 00000010H
  00b62	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00b65	85 c0		 test	 eax, eax
  00b67	74 46		 je	 SHORT $LN429@inflate

; 950  :                                 &(state->lenbits), state->work);
; 951  :             if (ret) {
; 952  :                 strm->msg = (char *)"invalid code lengths set";

  00b69	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b6c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
$LN932@inflate:

; 1013 :                 state->mode = BAD;

  00b73	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN888@inflate:
  00b7a	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN8@inflate:

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  00b7d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00b80	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00b85	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00b88	0f 86 07 f5 ff
	ff		 jbe	 $LL5@inflate
$LN499@inflate:
  00b8e	5f		 pop	 edi
  00b8f	5e		 pop	 esi

; 1239 :             goto inf_leave;
; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;
; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;

  00b90	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00b95	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  00b96	8b e5		 mov	 esp, ebp
  00b98	5d		 pop	 ebp
  00b99	c2 08 00	 ret	 8
$LN426@inflate:

; 930  :                 strm->msg = (char *)"too many length or distance symbols";

  00b9c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b9f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  00ba6	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00bad	eb ce		 jmp	 SHORT $LN8@inflate
$LN429@inflate:

; 954  :                 break;
; 955  :             }
; 956  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 957  :             state->have = 0;

  00baf	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 958  :             state->mode = CODELENS;

  00bb6	c7 41 04 46 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16198 ; 00003f46H
$LN535@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00bbd	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00bc0	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00bc3	39 41 6c	 cmp	 DWORD PTR [ecx+108], eax
  00bc6	0f 83 18 02 00
	00		 jae	 $LN186@inflate
  00bcc	0f 1f 40 00	 npad	 4
$LL185@inflate:

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  00bd0	8b 45 d0	 mov	 eax, DWORD PTR tv2837[ebp]
  00bd3	ba 01 00 00 00	 mov	 edx, 1
  00bd8	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bda	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bdd	d3 e2		 shl	 edx, cl
  00bdf	4a		 dec	 edx
  00be0	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00be3	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00be6	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  00be9	8b c8		 mov	 ecx, eax
  00beb	c1 e9 08	 shr	 ecx, 8
  00bee	0f b6 c9	 movzx	 ecx, cl
  00bf1	89 45 cc	 mov	 DWORD PTR _here$[ebp], eax
  00bf4	3b ce		 cmp	 ecx, esi
  00bf6	76 45		 jbe	 SHORT $LN562@inflate
$LL187@inflate:

; 964  :                     PULLBYTE();

  00bf8	85 db		 test	 ebx, ebx
  00bfa	0f 84 be f9 ff
	ff		 je	 $LN887@inflate
  00c00	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00c03	8b ce		 mov	 ecx, esi
  00c05	d3 e0		 shl	 eax, cl
  00c07	ba 01 00 00 00	 mov	 edx, 1
  00c0c	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  00c0f	4b		 dec	 ebx
  00c10	8b 45 d0	 mov	 eax, DWORD PTR tv2837[ebp]
  00c13	47		 inc	 edi
  00c14	83 c6 08	 add	 esi, 8
  00c17	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c1a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00c1d	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c1f	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00c22	d3 e2		 shl	 edx, cl
  00c24	4a		 dec	 edx
  00c25	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00c28	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00c2b	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00c2e	8b c8		 mov	 ecx, eax
  00c30	c1 e9 08	 shr	 ecx, 8
  00c33	0f b6 c9	 movzx	 ecx, cl
  00c36	89 45 cc	 mov	 DWORD PTR _here$[ebp], eax
  00c39	3b ce		 cmp	 ecx, esi
  00c3b	77 bb		 ja	 SHORT $LL187@inflate
$LN562@inflate:

; 965  :                 }
; 966  :                 if (here.val < 16) {

  00c3d	8b d0		 mov	 edx, eax
  00c3f	c1 ea 10	 shr	 edx, 16			; 00000010H
  00c42	66 83 fa 10	 cmp	 dx, 16			; 00000010H
  00c46	73 21		 jae	 SHORT $LN928@inflate

; 967  :                     DROPBITS(here.bits);

  00c48	c1 e8 08	 shr	 eax, 8
  00c4b	0f b6 c8	 movzx	 ecx, al
  00c4e	d3 6d fc	 shr	 DWORD PTR _hold$1$[ebp], cl
  00c51	2b f1		 sub	 esi, ecx

; 968  :                     state->lens[state->have++] = here.val;

  00c53	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c56	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c59	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00c5c	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00c61	ff 41 6c	 inc	 DWORD PTR [ecx+108]

; 969  :                 }

  00c64	e9 6a 01 00 00	 jmp	 $LN929@inflate
$LN928@inflate:

; 970  :                 else {
; 971  :                     if (here.val == 16) {

  00c69	75 73		 jne	 SHORT $LN435@inflate

; 972  :                         NEEDBITS(here.bits + 2);

  00c6b	8b c8		 mov	 ecx, eax
  00c6d	c1 e9 08	 shr	 ecx, 8
  00c70	0f b6 c9	 movzx	 ecx, cl
  00c73	83 c1 02	 add	 ecx, 2
  00c76	89 4d cc	 mov	 DWORD PTR $T1[ebp], ecx
  00c79	3b f1		 cmp	 esi, ecx
  00c7b	73 25		 jae	 SHORT $LN196@inflate
  00c7d	0f 1f 00	 npad	 3
$LL199@inflate:
  00c80	85 db		 test	 ebx, ebx
  00c82	0f 84 36 f9 ff
	ff		 je	 $LN887@inflate
  00c88	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00c8b	8b ce		 mov	 ecx, esi
  00c8d	d3 e2		 shl	 edx, cl
  00c8f	4b		 dec	 ebx
  00c90	01 55 fc	 add	 DWORD PTR _hold$1$[ebp], edx
  00c93	47		 inc	 edi
  00c94	83 c6 08	 add	 esi, 8
  00c97	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c9a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00c9d	3b 75 cc	 cmp	 esi, DWORD PTR $T1[ebp]
  00ca0	72 de		 jb	 SHORT $LL199@inflate
$LN196@inflate:

; 973  :                         DROPBITS(here.bits);

  00ca2	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00ca5	0f b6 cc	 movzx	 ecx, ah
  00ca8	d3 ea		 shr	 edx, cl
  00caa	2b f1		 sub	 esi, ecx

; 974  :                         if (state->have == 0) {

  00cac	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00caf	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cb2	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00cb5	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00cb8	85 c0		 test	 eax, eax
  00cba	0f 84 4a 01 00
	00		 je	 $LN567@inflate

; 976  :                             state->mode = BAD;
; 977  :                             break;
; 978  :                         }
; 979  :                         len = state->lens[state->have - 1];

  00cc0	0f b7 44 41 72	 movzx	 eax, WORD PTR [ecx+eax*2+114]
  00cc5	89 45 cc	 mov	 DWORD PTR _len$5$[ebp], eax

; 980  :                         copy = 3 + BITS(2);

  00cc8	8b c2		 mov	 eax, edx
  00cca	83 e0 03	 and	 eax, 3

; 981  :                         DROPBITS(2);

  00ccd	c1 ea 02	 shr	 edx, 2
  00cd0	83 c0 03	 add	 eax, 3
  00cd3	83 ee 02	 sub	 esi, 2
  00cd6	89 45 d8	 mov	 DWORD PTR _copy$8$[ebp], eax

; 982  :                     }

  00cd9	e9 b1 00 00 00	 jmp	 $LN930@inflate
$LN435@inflate:

; 983  :                     else if (here.val == 17) {

  00cde	66 83 7d ce 11	 cmp	 WORD PTR _here$[ebp+2], 17 ; 00000011H
  00ce3	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 984  :                         NEEDBITS(here.bits + 3);

  00ce6	0f b6 cc	 movzx	 ecx, ah
  00ce9	75 4a		 jne	 SHORT $LN226@inflate
  00ceb	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00cee	89 4d cc	 mov	 DWORD PTR tv2722[ebp], ecx
  00cf1	3b f0		 cmp	 esi, eax
  00cf3	73 29		 jae	 SHORT $LN210@inflate
$LL213@inflate:
  00cf5	85 db		 test	 ebx, ebx
  00cf7	0f 84 c1 f8 ff
	ff		 je	 $LN887@inflate
  00cfd	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00d00	8b ce		 mov	 ecx, esi
  00d02	d3 e0		 shl	 eax, cl
  00d04	4b		 dec	 ebx
  00d05	8b 4d cc	 mov	 ecx, DWORD PTR tv2722[ebp]
  00d08	03 d0		 add	 edx, eax
  00d0a	47		 inc	 edi
  00d0b	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00d0e	83 c6 08	 add	 esi, 8
  00d11	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d14	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00d17	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00d1a	3b f0		 cmp	 esi, eax
  00d1c	72 d7		 jb	 SHORT $LL213@inflate
$LN210@inflate:

; 985  :                         DROPBITS(here.bits);

  00d1e	d3 ea		 shr	 edx, cl

; 986  :                         len = 0;
; 987  :                         copy = 3 + BITS(3);

  00d20	8b c2		 mov	 eax, edx
  00d22	83 e0 07	 and	 eax, 7
  00d25	83 c0 03	 add	 eax, 3

; 988  :                         DROPBITS(3);

  00d28	c1 ea 03	 shr	 edx, 3
  00d2b	89 45 d8	 mov	 DWORD PTR _copy$8$[ebp], eax
  00d2e	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 989  :                     }

  00d33	eb 49		 jmp	 SHORT $LN931@inflate
$LN226@inflate:

; 990  :                     else {
; 991  :                         NEEDBITS(here.bits + 7);

  00d35	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00d38	89 4d cc	 mov	 DWORD PTR tv2720[ebp], ecx
  00d3b	3b f0		 cmp	 esi, eax
  00d3d	73 2a		 jae	 SHORT $LN224@inflate
  00d3f	90		 npad	 1
$LL227@inflate:
  00d40	85 db		 test	 ebx, ebx
  00d42	0f 84 76 f8 ff
	ff		 je	 $LN887@inflate
  00d48	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00d4b	8b ce		 mov	 ecx, esi
  00d4d	d3 e0		 shl	 eax, cl
  00d4f	4b		 dec	 ebx
  00d50	8b 4d cc	 mov	 ecx, DWORD PTR tv2720[ebp]
  00d53	03 d0		 add	 edx, eax
  00d55	47		 inc	 edi
  00d56	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00d59	83 c6 08	 add	 esi, 8
  00d5c	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d5f	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00d62	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00d65	3b f0		 cmp	 esi, eax
  00d67	72 d7		 jb	 SHORT $LL227@inflate
$LN224@inflate:

; 992  :                         DROPBITS(here.bits);

  00d69	d3 ea		 shr	 edx, cl

; 993  :                         len = 0;
; 994  :                         copy = 11 + BITS(7);

  00d6b	8b c2		 mov	 eax, edx
  00d6d	83 e0 7f	 and	 eax, 127		; 0000007fH
  00d70	83 c0 0b	 add	 eax, 11			; 0000000bH

; 995  :                         DROPBITS(7);

  00d73	c1 ea 07	 shr	 edx, 7
  00d76	89 45 d8	 mov	 DWORD PTR _copy$8$[ebp], eax
  00d79	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN931@inflate:
  00d7e	2b c1		 sub	 eax, ecx
  00d80	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _len$5$[ebp], 0
  00d87	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d8a	03 f0		 add	 esi, eax
  00d8c	8b 45 d8	 mov	 eax, DWORD PTR _copy$8$[ebp]
$LN930@inflate:

; 996  :                     }
; 997  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d8f	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  00d92	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00d95	03 c8		 add	 ecx, eax
  00d97	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00d9a	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d9d	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00da0	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  00da3	03 47 64	 add	 eax, DWORD PTR [edi+100]
  00da6	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00da9	3b c8		 cmp	 ecx, eax
  00dab	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00dae	77 5a		 ja	 SHORT $LN567@inflate
  00db0	8b 55 d8	 mov	 edx, DWORD PTR _copy$8$[ebp]
  00db3	8b 5d cc	 mov	 ebx, DWORD PTR _len$5$[ebp]
  00db6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL238@inflate:

; 998  :                         strm->msg = (char *)"invalid bit length repeat";
; 999  :                         state->mode = BAD;
; 1000 :                         break;
; 1001 :                     }
; 1002 :                     while (copy--)
; 1003 :                         state->lens[state->have++] = (unsigned short)len;

  00dc0	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00dc3	66 89 5c 41 74	 mov	 WORD PTR [ecx+eax*2+116], bx
  00dc8	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00dcb	83 ea 01	 sub	 edx, 1
  00dce	75 f0		 jne	 SHORT $LL238@inflate
  00dd0	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN929@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00dd3	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00dd6	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00dd9	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00ddc	3b d0		 cmp	 edx, eax
  00dde	0f 82 ec fd ff
	ff		 jb	 $LL185@inflate
$LN186@inflate:

; 1004 :                 }
; 1005 :             }
; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  00de4	81 79 04 51 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00deb	0f 84 89 fd ff
	ff		 je	 $LN888@inflate

; 1009 : 
; 1010 :             /* check for end-of-block code (better have one) */
; 1011 :             if (state->lens[256] == 0) {

  00df1	66 83 b9 74 02
	00 00 00	 cmp	 WORD PTR [ecx+628], 0
  00df9	75 25		 jne	 SHORT $LN445@inflate

; 1012 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00dfb	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00dfe	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 1014 :                 break;

  00e05	e9 69 fd ff ff	 jmp	 $LN932@inflate
$LN567@inflate:

; 975  :                             strm->msg = (char *)"invalid bit length repeat";

  00e0a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e0d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00e14	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00e1b	e9 5d fd ff ff	 jmp	 $LN8@inflate
$LN445@inflate:

; 1015 :             }
; 1016 : 
; 1017 :             /* build code tables -- note: do not change the lenbits or distbits
; 1018 :                values here (9 and 6) without reading the comments in inftrees.h
; 1019 :                concerning the ENOUGH constants, which depend on those values */
; 1020 :             state->next = state->codes;

  00e20	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]

; 1021 :             state->lencode = (const code FAR *)(state->next);
; 1022 :             state->lenbits = 9;

  00e23	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9
  00e2a	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  00e30	89 55 cc	 mov	 DWORD PTR tv2737[ebp], edx
  00e33	89 02		 mov	 DWORD PTR [edx], eax
  00e35	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 1023 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00e38	8d 81 f4 02 00
	00		 lea	 eax, DWORD PTR [ecx+756]
  00e3e	50		 push	 eax
  00e3f	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00e42	50		 push	 eax
  00e43	52		 push	 edx
  00e44	ff 71 64	 push	 DWORD PTR [ecx+100]
  00e47	8d 51 74	 lea	 edx, DWORD PTR [ecx+116]
  00e4a	b9 01 00 00 00	 mov	 ecx, 1
  00e4f	e8 00 00 00 00	 call	 _inflate_table

; 1027 :                 state->mode = BAD;

  00e54	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e57	83 c4 10	 add	 esp, 16			; 00000010H
  00e5a	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00e5d	85 c0		 test	 eax, eax
  00e5f	74 0f		 je	 SHORT $LN446@inflate

; 1024 :                                 &(state->lenbits), state->work);
; 1025 :             if (ret) {
; 1026 :                 strm->msg = (char *)"invalid literal/lengths set";

  00e61	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e64	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 1028 :                 break;

  00e6b	e9 03 fd ff ff	 jmp	 $LN932@inflate
$LN446@inflate:

; 1029 :             }
; 1030 :             state->distcode = (const code FAR *)(state->next);

  00e70	8b 55 cc	 mov	 edx, DWORD PTR tv2737[ebp]

; 1031 :             state->distbits = 6;

  00e73	c7 41 5c 06 00
	00 00		 mov	 DWORD PTR [ecx+92], 6
  00e7a	8b 02		 mov	 eax, DWORD PTR [edx]
  00e7c	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 1032 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00e7f	8d 81 f4 02 00
	00		 lea	 eax, DWORD PTR [ecx+756]
  00e85	50		 push	 eax
  00e86	8d 41 5c	 lea	 eax, DWORD PTR [ecx+92]
  00e89	50		 push	 eax
  00e8a	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00e8d	52		 push	 edx
  00e8e	ff 71 68	 push	 DWORD PTR [ecx+104]
  00e91	83 c1 74	 add	 ecx, 116		; 00000074H
  00e94	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00e97	b9 02 00 00 00	 mov	 ecx, 2
  00e9c	e8 00 00 00 00	 call	 _inflate_table

; 1036 :                 state->mode = BAD;

  00ea1	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00ea4	83 c4 10	 add	 esp, 16			; 00000010H
  00ea7	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00eaa	85 c0		 test	 eax, eax
  00eac	74 0f		 je	 SHORT $LN447@inflate

; 1033 :                             &(state->next), &(state->distbits), state->work);
; 1034 :             if (ret) {
; 1035 :                 strm->msg = (char *)"invalid distances set";

  00eae	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00eb1	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 1037 :                 break;

  00eb8	e9 b6 fc ff ff	 jmp	 $LN932@inflate
$LN447@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;
; 1041 :             if (flush == Z_TREES) goto inf_leave;

  00ebd	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  00ec0	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  00ec7	83 fa 06	 cmp	 edx, 6
  00eca	0f 84 30 07 00
	00		 je	 $LN863@inflate
  00ed0	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN448@inflate:

; 1042 :         case LEN_:
; 1043 :             state->mode = LEN;

  00ed3	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
$LN450@inflate:

; 1044 :         case LEN:
; 1045 :             if (have >= 6 && left >= 258) {

  00eda	83 fb 06	 cmp	 ebx, 6
  00edd	72 77		 jb	 SHORT $LN451@inflate
  00edf	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00ee6	72 6e		 jb	 SHORT $LN451@inflate

; 1046 :                 RESTORE();

  00ee8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00eeb	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]

; 1047 :                 inflate_fast(strm, out);

  00eee	ff 75 dc	 push	 DWORD PTR _out$1$[ebp]
  00ef1	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00ef4	8b 7d e8	 mov	 edi, DWORD PTR _left$1$[ebp]
  00ef7	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00efa	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00efd	89 38		 mov	 DWORD PTR [eax], edi
  00eff	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00f02	50		 push	 eax
  00f03	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  00f06	89 71 40	 mov	 DWORD PTR [ecx+64], esi
  00f09	e8 00 00 00 00	 call	 _inflate_fast

; 1048 :                 LOAD();

  00f0e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00f11	83 c4 08	 add	 esp, 8
  00f14	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00f17	8b 38		 mov	 edi, DWORD PTR [eax]
  00f19	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00f1c	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  00f1f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00f22	89 4d e8	 mov	 DWORD PTR _left$1$[ebp], ecx
  00f25	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00f28	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00f2b	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx

; 1049 :                 if (state->mode == TYPE)

  00f2e	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  00f35	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00f38	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00f3b	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00f3e	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00f41	0f 85 36 fc ff
	ff		 jne	 $LN8@inflate

; 1050 :                     state->back = -1;

  00f47	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 1051 :                 break;

  00f51	e9 27 fc ff ff	 jmp	 $LN8@inflate
$LN451@inflate:

; 1052 :             }
; 1053 :             state->back = 0;
; 1054 :             for (;;) {
; 1055 :                 here = state->lencode[BITS(state->lenbits)];

  00f56	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00f59	c7 81 c8 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7112], 0
  00f63	8b 4d d0	 mov	 ecx, DWORD PTR tv2837[ebp]
  00f66	89 45 d8	 mov	 DWORD PTR tv2735[ebp], eax
  00f69	b8 01 00 00 00	 mov	 eax, 1
  00f6e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00f70	d3 e0		 shl	 eax, cl
  00f72	8b 4d d8	 mov	 ecx, DWORD PTR tv2735[ebp]
  00f75	48		 dec	 eax
  00f76	23 c2		 and	 eax, edx
  00f78	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1056 :                 if ((unsigned)(here.bits) <= bits) break;

  00f7b	8b c8		 mov	 ecx, eax
  00f7d	c1 e9 08	 shr	 ecx, 8
  00f80	0f b6 c9	 movzx	 ecx, cl
  00f83	3b ce		 cmp	 ecx, esi
  00f85	76 47		 jbe	 SHORT $LN569@inflate
$LL246@inflate:

; 1057 :                 PULLBYTE();

  00f87	85 db		 test	 ebx, ebx
  00f89	0f 84 2f f6 ff
	ff		 je	 $LN887@inflate
  00f8f	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00f92	8b ce		 mov	 ecx, esi
  00f94	d3 e0		 shl	 eax, cl
  00f96	4b		 dec	 ebx
  00f97	03 d0		 add	 edx, eax
  00f99	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00f9c	8b 45 d0	 mov	 eax, DWORD PTR tv2837[ebp]
  00f9f	47		 inc	 edi
  00fa0	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00fa3	83 c6 08	 add	 esi, 8
  00fa6	ba 01 00 00 00	 mov	 edx, 1
  00fab	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00fae	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fb0	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00fb3	d3 e2		 shl	 edx, cl
  00fb5	4a		 dec	 edx
  00fb6	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00fb9	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00fbc	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00fbf	8b c8		 mov	 ecx, eax
  00fc1	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00fc4	c1 e9 08	 shr	 ecx, 8
  00fc7	0f b6 c9	 movzx	 ecx, cl
  00fca	3b ce		 cmp	 ecx, esi
  00fcc	77 b9		 ja	 SHORT $LL246@inflate
$LN569@inflate:

; 1058 :             }
; 1059 :             if (here.op && (here.op & 0xf0) == 0) {

  00fce	84 c0		 test	 al, al
  00fd0	0f 84 b8 00 00
	00		 je	 $LN263@inflate
  00fd6	a8 f0		 test	 al, 240			; 000000f0H
  00fd8	0f 85 b0 00 00
	00		 jne	 $LN263@inflate

; 1060 :                 last = here;
; 1061 :                 for (;;) {
; 1062 :                     here = state->lencode[last.val +

  00fde	8b c8		 mov	 ecx, eax
  00fe0	bb 01 00 00 00	 mov	 ebx, 1
  00fe5	c1 e9 08	 shr	 ecx, 8
  00fe8	8b d0		 mov	 edx, eax
  00fea	0f b6 f9	 movzx	 edi, cl
  00fed	89 4d ec	 mov	 DWORD PTR tv2734[ebp], ecx
  00ff0	0f b6 c8	 movzx	 ecx, al
  00ff3	03 cf		 add	 ecx, edi
  00ff5	c1 e8 10	 shr	 eax, 16			; 00000010H
  00ff8	d3 e3		 shl	 ebx, cl
  00ffa	8b cf		 mov	 ecx, edi
  00ffc	4b		 dec	 ebx
  00ffd	89 55 cc	 mov	 DWORD PTR _last$[ebp], edx
  01000	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  01003	d3 eb		 shr	 ebx, cl
  01005	8b 4d d8	 mov	 ecx, DWORD PTR tv2735[ebp]
  01008	03 d8		 add	 ebx, eax
  0100a	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1063 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1064 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0100d	8b c8		 mov	 ecx, eax
  0100f	c1 e9 08	 shr	 ecx, 8
  01012	0f b6 f9	 movzx	 edi, cl
  01015	8b 4d ec	 mov	 ecx, DWORD PTR tv2734[ebp]
  01018	0f b6 c9	 movzx	 ecx, cl
  0101b	03 f9		 add	 edi, ecx
  0101d	3b fe		 cmp	 edi, esi
  0101f	76 57		 jbe	 SHORT $LN260@inflate
$LL252@inflate:

; 1065 :                     PULLBYTE();

  01021	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01024	85 c0		 test	 eax, eax
  01026	0f 84 95 f5 ff
	ff		 je	 $LN896@inflate
  0102c	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  0102f	48		 dec	 eax
  01030	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  01033	8b ce		 mov	 ecx, esi
  01035	bf 01 00 00 00	 mov	 edi, 1
  0103a	83 c6 08	 add	 esi, 8
  0103d	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  01040	43		 inc	 ebx
  01041	d3 e0		 shl	 eax, cl
  01043	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  01046	0f b7 45 ce	 movzx	 eax, WORD PTR _last$[ebp+2]
  0104a	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0104d	0f b6 de	 movzx	 ebx, dh
  01050	0f b6 ca	 movzx	 ecx, dl
  01053	03 cb		 add	 ecx, ebx
  01055	d3 e7		 shl	 edi, cl
  01057	8b cb		 mov	 ecx, ebx
  01059	4f		 dec	 edi
  0105a	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  0105d	d3 ef		 shr	 edi, cl
  0105f	03 f8		 add	 edi, eax
  01061	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  01064	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  01067	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  0106a	8b c8		 mov	 ecx, eax
  0106c	c1 e9 08	 shr	 ecx, 8
  0106f	0f b6 c9	 movzx	 ecx, cl
  01072	03 cb		 add	 ecx, ebx
  01074	3b ce		 cmp	 ecx, esi
  01076	77 a9		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1066 :                 }
; 1067 :                 DROPBITS(last.bits);
; 1068 :                 state->back += last.bits;

  01078	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  0107b	0f b6 ce	 movzx	 ecx, dh
  0107e	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01081	d3 ea		 shr	 edx, cl
  01083	2b f1		 sub	 esi, ecx
  01085	89 8b c8 1b 00
	00		 mov	 DWORD PTR [ebx+7112], ecx
  0108b	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN263@inflate:

; 1069 :             }
; 1070 :             DROPBITS(here.bits);
; 1071 :             state->back += here.bits;

  0108e	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  01091	8b c8		 mov	 ecx, eax
  01093	c1 e9 08	 shr	 ecx, 8
  01096	0f b6 c9	 movzx	 ecx, cl
  01099	d3 ea		 shr	 edx, cl
  0109b	2b f1		 sub	 esi, ecx
  0109d	01 8f c8 1b 00
	00		 add	 DWORD PTR [edi+7112], ecx

; 1072 :             state->length = (unsigned)here.val;

  010a3	8b c8		 mov	 ecx, eax
  010a5	c1 e9 10	 shr	 ecx, 16			; 00000010H
  010a8	89 4f 44	 mov	 DWORD PTR [edi+68], ecx

; 1073 :             if ((int)(here.op) == 0) {

  010ab	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]

; 1074 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1075 :                         "inflate:         literal '%c'\n" :
; 1076 :                         "inflate:         literal 0x%02x\n", here.val));
; 1077 :                 state->mode = LIT;

  010ae	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  010b1	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  010b4	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  010b7	84 c0		 test	 al, al
  010b9	75 0c		 jne	 SHORT $LN458@inflate
  010bb	c7 41 04 4d 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16205 ; 00003f4dH

; 1078 :                 break;

  010c2	e9 b6 fa ff ff	 jmp	 $LN8@inflate
$LN458@inflate:

; 1079 :             }
; 1080 :             if (here.op & 32) {

  010c7	a8 20		 test	 al, 32			; 00000020H
  010c9	74 16		 je	 SHORT $LN459@inflate

; 1081 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1082 :                 state->back = -1;

  010cb	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1
$LN419@inflate:

; 1083 :                 state->mode = TYPE;

  010d5	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 1084 :                 break;

  010dc	e9 9c fa ff ff	 jmp	 $LN8@inflate
$LN459@inflate:

; 1085 :             }
; 1086 :             if (here.op & 64) {

  010e1	a8 40		 test	 al, 64			; 00000040H
  010e3	74 16		 je	 SHORT $LN460@inflate

; 1087 :                 strm->msg = (char *)"invalid literal/length code";

  010e5	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  010e8	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  010ef	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  010f6	e9 82 fa ff ff	 jmp	 $LN8@inflate
$LN460@inflate:

; 1088 :                 state->mode = BAD;
; 1089 :                 break;
; 1090 :             }
; 1091 :             state->extra = (unsigned)(here.op) & 15;

  010fb	0f b6 c0	 movzx	 eax, al
  010fe	83 e0 0f	 and	 eax, 15			; 0000000fH

; 1092 :             state->mode = LENEXT;

  01101	c7 41 04 49 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16201 ; 00003f49H
  01108	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
$LN461@inflate:

; 1093 :         case LENEXT:
; 1094 :             if (state->extra) {

  0110b	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0110e	89 45 cc	 mov	 DWORD PTR tv2709[ebp], eax
  01111	85 c0		 test	 eax, eax
  01113	74 57		 je	 SHORT $LN462@inflate

; 1095 :                 NEEDBITS(state->extra);

  01115	3b f0		 cmp	 esi, eax
  01117	73 2b		 jae	 SHORT $LN264@inflate
  01119	0f 1f 80 00 00
	00 00		 npad	 7
$LL267@inflate:
  01120	85 db		 test	 ebx, ebx
  01122	0f 84 96 f4 ff
	ff		 je	 $LN887@inflate
  01128	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0112b	8b ce		 mov	 ecx, esi
  0112d	d3 e0		 shl	 eax, cl
  0112f	4b		 dec	 ebx
  01130	03 d0		 add	 edx, eax
  01132	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01135	47		 inc	 edi
  01136	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01139	83 c6 08	 add	 esi, 8
  0113c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0113f	3b 75 cc	 cmp	 esi, DWORD PTR tv2709[ebp]
  01142	72 dc		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1096 :                 state->length += BITS(state->extra);

  01144	8b 4d cc	 mov	 ecx, DWORD PTR tv2709[ebp]
  01147	b8 01 00 00 00	 mov	 eax, 1
  0114c	d3 e0		 shl	 eax, cl
  0114e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01151	48		 dec	 eax
  01152	23 c2		 and	 eax, edx
  01154	01 41 44	 add	 DWORD PTR [ecx+68], eax

; 1097 :                 DROPBITS(state->extra);

  01157	8b 45 cc	 mov	 eax, DWORD PTR tv2709[ebp]
  0115a	8b c8		 mov	 ecx, eax
  0115c	d3 ea		 shr	 edx, cl
  0115e	2b f0		 sub	 esi, eax

; 1098 :                 state->back += state->extra;

  01160	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01163	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01166	01 81 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], eax
$LN462@inflate:

; 1099 :             }
; 1100 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1101 :             state->was = state->length;

  0116c	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0116f	89 81 cc 1b 00
	00		 mov	 DWORD PTR [ecx+7116], eax

; 1102 :             state->mode = DIST;

  01175	c7 41 04 4a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16202 ; 00003f4aH
$LN464@inflate:

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  0117c	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0117f	8b 4d c4	 mov	 ecx, DWORD PTR tv2834[ebp]
  01182	89 45 d8	 mov	 DWORD PTR tv2706[ebp], eax
  01185	b8 01 00 00 00	 mov	 eax, 1
  0118a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0118c	d3 e0		 shl	 eax, cl
  0118e	8b 4d d8	 mov	 ecx, DWORD PTR tv2706[ebp]
  01191	48		 dec	 eax
  01192	23 c2		 and	 eax, edx
  01194	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1106 :                 if ((unsigned)(here.bits) <= bits) break;

  01197	8b c8		 mov	 ecx, eax
  01199	c1 e9 08	 shr	 ecx, 8
  0119c	0f b6 c9	 movzx	 ecx, cl
  0119f	3b ce		 cmp	 ecx, esi
  011a1	76 47		 jbe	 SHORT $LN574@inflate
$LL275@inflate:

; 1107 :                 PULLBYTE();

  011a3	85 db		 test	 ebx, ebx
  011a5	0f 84 13 f4 ff
	ff		 je	 $LN887@inflate
  011ab	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  011ae	8b ce		 mov	 ecx, esi
  011b0	d3 e0		 shl	 eax, cl
  011b2	4b		 dec	 ebx
  011b3	03 d0		 add	 edx, eax
  011b5	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  011b8	8b 45 c4	 mov	 eax, DWORD PTR tv2834[ebp]
  011bb	47		 inc	 edi
  011bc	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  011bf	83 c6 08	 add	 esi, 8
  011c2	ba 01 00 00 00	 mov	 edx, 1
  011c7	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  011ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  011cc	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  011cf	d3 e2		 shl	 edx, cl
  011d1	4a		 dec	 edx
  011d2	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  011d5	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  011d8	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  011db	8b c8		 mov	 ecx, eax
  011dd	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  011e0	c1 e9 08	 shr	 ecx, 8
  011e3	0f b6 c9	 movzx	 ecx, cl
  011e6	3b ce		 cmp	 ecx, esi
  011e8	77 b9		 ja	 SHORT $LL275@inflate
$LN574@inflate:

; 1108 :             }
; 1109 :             if ((here.op & 0xf0) == 0) {

  011ea	a8 f0		 test	 al, 240			; 000000f0H
  011ec	0f 85 af 00 00
	00		 jne	 $LN892@inflate

; 1110 :                 last = here;
; 1111 :                 for (;;) {
; 1112 :                     here = state->distcode[last.val +

  011f2	8b c8		 mov	 ecx, eax
  011f4	bb 01 00 00 00	 mov	 ebx, 1
  011f9	c1 e9 08	 shr	 ecx, 8
  011fc	8b d0		 mov	 edx, eax
  011fe	0f b6 f9	 movzx	 edi, cl
  01201	89 4d ec	 mov	 DWORD PTR tv2732[ebp], ecx
  01204	0f b6 c8	 movzx	 ecx, al
  01207	03 cf		 add	 ecx, edi
  01209	c1 e8 10	 shr	 eax, 16			; 00000010H
  0120c	d3 e3		 shl	 ebx, cl
  0120e	8b cf		 mov	 ecx, edi
  01210	4b		 dec	 ebx
  01211	89 55 cc	 mov	 DWORD PTR _last$[ebp], edx
  01214	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  01217	d3 eb		 shr	 ebx, cl
  01219	8b 4d d8	 mov	 ecx, DWORD PTR tv2706[ebp]
  0121c	03 d8		 add	 ebx, eax
  0121e	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1113 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1114 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01221	8b c8		 mov	 ecx, eax
  01223	c1 e9 08	 shr	 ecx, 8
  01226	0f b6 f9	 movzx	 edi, cl
  01229	8b 4d ec	 mov	 ecx, DWORD PTR tv2732[ebp]
  0122c	0f b6 c9	 movzx	 ecx, cl
  0122f	03 f9		 add	 edi, ecx
  01231	3b fe		 cmp	 edi, esi
  01233	76 57		 jbe	 SHORT $LN289@inflate
$LL281@inflate:

; 1115 :                     PULLBYTE();

  01235	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01238	85 c0		 test	 eax, eax
  0123a	0f 84 81 f3 ff
	ff		 je	 $LN896@inflate
  01240	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  01243	48		 dec	 eax
  01244	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  01247	8b ce		 mov	 ecx, esi
  01249	bf 01 00 00 00	 mov	 edi, 1
  0124e	83 c6 08	 add	 esi, 8
  01251	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  01254	43		 inc	 ebx
  01255	d3 e0		 shl	 eax, cl
  01257	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  0125a	0f b7 45 ce	 movzx	 eax, WORD PTR _last$[ebp+2]
  0125e	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  01261	0f b6 de	 movzx	 ebx, dh
  01264	0f b6 ca	 movzx	 ecx, dl
  01267	03 cb		 add	 ecx, ebx
  01269	d3 e7		 shl	 edi, cl
  0126b	8b cb		 mov	 ecx, ebx
  0126d	4f		 dec	 edi
  0126e	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  01271	d3 ef		 shr	 edi, cl
  01273	03 f8		 add	 edi, eax
  01275	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  01278	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  0127b	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  0127e	8b c8		 mov	 ecx, eax
  01280	c1 e9 08	 shr	 ecx, 8
  01283	0f b6 c9	 movzx	 ecx, cl
  01286	03 cb		 add	 ecx, ebx
  01288	3b ce		 cmp	 ecx, esi
  0128a	77 a9		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1116 :                 }
; 1117 :                 DROPBITS(last.bits);
; 1118 :                 state->back += last.bits;

  0128c	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  0128f	0f b6 ce	 movzx	 ecx, dh
  01292	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01295	2b f1		 sub	 esi, ecx
  01297	d3 ea		 shr	 edx, cl
  01299	01 8b c8 1b 00
	00		 add	 DWORD PTR [ebx+7112], ecx
  0129f	eb 03		 jmp	 SHORT $LN292@inflate
$LN892@inflate:
  012a1	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
$LN292@inflate:

; 1125 :                 break;

  012a4	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  012a7	8b c8		 mov	 ecx, eax
  012a9	c1 e9 08	 shr	 ecx, 8
  012ac	0f b6 c9	 movzx	 ecx, cl
  012af	01 8b c8 1b 00
	00		 add	 DWORD PTR [ebx+7112], ecx
  012b5	2b f1		 sub	 esi, ecx
  012b7	d3 ea		 shr	 edx, cl
  012b9	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  012bc	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  012bf	a8 40		 test	 al, 64			; 00000040H
  012c1	74 1c		 je	 SHORT $LN470@inflate

; 1119 :             }
; 1120 :             DROPBITS(here.bits);
; 1121 :             state->back += here.bits;
; 1122 :             if (here.op & 64) {
; 1123 :                 strm->msg = (char *)"invalid distance code";
; 1124 :                 state->mode = BAD;

  012c3	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  012c6	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 1125 :                 break;

  012c9	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  012cc	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  012d3	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  012da	e9 9e f8 ff ff	 jmp	 $LN8@inflate
$LN470@inflate:

; 1126 :             }
; 1127 :             state->offset = (unsigned)here.val;

  012df	8b c8		 mov	 ecx, eax

; 1128 :             state->extra = (unsigned)(here.op) & 15;

  012e1	0f b6 c0	 movzx	 eax, al
  012e4	c1 e9 10	 shr	 ecx, 16			; 00000010H
  012e7	83 e0 0f	 and	 eax, 15			; 0000000fH
  012ea	89 4b 48	 mov	 DWORD PTR [ebx+72], ecx
  012ed	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  012f0	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  012f3	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1129 :             state->mode = DISTEXT;

  012f6	c7 41 04 4b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16203 ; 00003f4bH
$LN471@inflate:

; 1130 :         case DISTEXT:
; 1131 :             if (state->extra) {

  012fd	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  01300	89 45 cc	 mov	 DWORD PTR tv2707[ebp], eax
  01303	85 c0		 test	 eax, eax
  01305	74 58		 je	 SHORT $LN472@inflate

; 1132 :                 NEEDBITS(state->extra);

  01307	3b f0		 cmp	 esi, eax
  01309	73 29		 jae	 SHORT $LN293@inflate
  0130b	0f 1f 44 00 00	 npad	 5
$LL296@inflate:
  01310	85 db		 test	 ebx, ebx
  01312	0f 84 a6 f2 ff
	ff		 je	 $LN887@inflate
  01318	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0131b	8b ce		 mov	 ecx, esi
  0131d	d3 e0		 shl	 eax, cl
  0131f	4b		 dec	 ebx
  01320	03 d0		 add	 edx, eax
  01322	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01325	47		 inc	 edi
  01326	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01329	83 c6 08	 add	 esi, 8
  0132c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0132f	3b 75 cc	 cmp	 esi, DWORD PTR tv2707[ebp]
  01332	72 dc		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1133 :                 state->offset += BITS(state->extra);

  01334	8b 4d cc	 mov	 ecx, DWORD PTR tv2707[ebp]
  01337	b8 01 00 00 00	 mov	 eax, 1
  0133c	d3 e0		 shl	 eax, cl
  0133e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01341	48		 dec	 eax
  01342	23 c2		 and	 eax, edx
  01344	01 41 48	 add	 DWORD PTR [ecx+72], eax

; 1134 :                 DROPBITS(state->extra);

  01347	8b 45 cc	 mov	 eax, DWORD PTR tv2707[ebp]
  0134a	8b c8		 mov	 ecx, eax
  0134c	d3 ea		 shr	 edx, cl
  0134e	2b f0		 sub	 esi, eax

; 1135 :                 state->back += state->extra;

  01350	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01353	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01356	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01359	01 81 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], eax
$LN472@inflate:

; 1136 :             }
; 1137 : #ifdef INFLATE_STRICT
; 1138 :             if (state->offset > state->dmax) {
; 1139 :                 strm->msg = (char *)"invalid distance too far back";
; 1140 :                 state->mode = BAD;
; 1141 :                 break;
; 1142 :             }
; 1143 : #endif
; 1144 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1145 :             state->mode = MATCH;

  0135f	c7 41 04 4c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16204 ; 00003f4cH
$LN474@inflate:

; 1146 :         case MATCH:
; 1147 :             if (left == 0) goto inf_leave;

  01366	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  0136a	0f 84 4e f2 ff
	ff		 je	 $LN887@inflate

; 1148 :             copy = out - left;

  01370	8b 45 dc	 mov	 eax, DWORD PTR _out$1$[ebp]
  01373	2b 45 e8	 sub	 eax, DWORD PTR _left$1$[ebp]
  01376	89 45 cc	 mov	 DWORD PTR _copy$9$[ebp], eax

; 1149 :             if (state->offset > copy) {         /* copy from window */

  01379	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  0137c	3b 45 cc	 cmp	 eax, DWORD PTR _copy$9$[ebp]
  0137f	76 55		 jbe	 SHORT $LN476@inflate

; 1150 :                 copy = state->offset - copy;

  01381	2b 45 cc	 sub	 eax, DWORD PTR _copy$9$[ebp]

; 1151 :                 if (copy > state->whave) {

  01384	3b 41 30	 cmp	 eax, DWORD PTR [ecx+48]
  01387	76 1f		 jbe	 SHORT $LN479@inflate

; 1152 :                     if (state->sane) {

  01389	83 b9 c4 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7108], 0
  01390	74 16		 je	 SHORT $LN479@inflate

; 1153 :                         strm->msg = (char *)"invalid distance too far back";

  01392	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01395	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  0139c	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  013a3	e9 d5 f7 ff ff	 jmp	 $LN8@inflate
$LN479@inflate:

; 1154 :                         state->mode = BAD;
; 1155 :                         break;
; 1156 :                     }
; 1157 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1158 :                     Trace((stderr, "inflate.c too far\n"));
; 1159 :                     copy -= state->whave;
; 1160 :                     if (copy > state->length) copy = state->length;
; 1161 :                     if (copy > left) copy = left;
; 1162 :                     left -= copy;
; 1163 :                     state->length -= copy;
; 1164 :                     do {
; 1165 :                         *put++ = 0;
; 1166 :                     } while (--copy);
; 1167 :                     if (state->length == 0) state->mode = LEN;
; 1168 :                     break;
; 1169 : #endif
; 1170 :                 }
; 1171 :                 if (copy > state->wnext) {

  013a8	3b 41 34	 cmp	 eax, DWORD PTR [ecx+52]
  013ab	76 10		 jbe	 SHORT $LN480@inflate

; 1172 :                     copy -= state->wnext;
; 1173 :                     from = state->window + (state->wsize - copy);

  013ad	8b 79 38	 mov	 edi, DWORD PTR [ecx+56]
  013b0	2b 41 34	 sub	 eax, DWORD PTR [ecx+52]
  013b3	03 79 2c	 add	 edi, DWORD PTR [ecx+44]
  013b6	2b f8		 sub	 edi, eax
  013b8	89 7d d8	 mov	 DWORD PTR _from$1$[ebp], edi

; 1174 :                 }

  013bb	eb 0b		 jmp	 SHORT $LN481@inflate
$LN480@inflate:

; 1175 :                 else
; 1176 :                     from = state->window + (state->wnext - copy);

  013bd	8b 59 38	 mov	 ebx, DWORD PTR [ecx+56]
  013c0	2b d8		 sub	 ebx, eax
  013c2	03 59 34	 add	 ebx, DWORD PTR [ecx+52]
  013c5	89 5d d8	 mov	 DWORD PTR _from$1$[ebp], ebx
$LN481@inflate:

; 1177 :                 if (copy > state->length) copy = state->length;

  013c8	8b 79 44	 mov	 edi, DWORD PTR [ecx+68]
  013cb	89 7d cc	 mov	 DWORD PTR tv2665[ebp], edi
  013ce	3b c7		 cmp	 eax, edi
  013d0	76 13		 jbe	 SHORT $LN477@inflate
  013d2	8b c7		 mov	 eax, edi

; 1178 :             }

  013d4	eb 0f		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1179 :             else {                              /* copy from output */
; 1180 :                 from = put - state->offset;

  013d6	8b 5d e0	 mov	 ebx, DWORD PTR _put$1$[ebp]
  013d9	89 5d d8	 mov	 DWORD PTR _from$1$[ebp], ebx
  013dc	29 45 d8	 sub	 DWORD PTR _from$1$[ebp], eax

; 1181 :                 copy = state->length;

  013df	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  013e2	89 45 cc	 mov	 DWORD PTR tv2665[ebp], eax
$LN477@inflate:

; 1182 :             }
; 1183 :             if (copy > left) copy = left;

  013e5	8b 5d e8	 mov	 ebx, DWORD PTR _left$1$[ebp]
  013e8	3b c3		 cmp	 eax, ebx
  013ea	0f 47 c3	 cmova	 eax, ebx

; 1184 :             left -= copy;

  013ed	2b d8		 sub	 ebx, eax
  013ef	89 45 c0	 mov	 DWORD PTR _copy$11$[ebp], eax
  013f2	89 5d e8	 mov	 DWORD PTR _left$1$[ebp], ebx
  013f5	8b f8		 mov	 edi, eax

; 1185 :             state->length -= copy;

  013f7	8b 5d cc	 mov	 ebx, DWORD PTR tv2665[ebp]
  013fa	2b d8		 sub	 ebx, eax
  013fc	89 59 44	 mov	 DWORD PTR [ecx+68], ebx

; 1188 :             } while (--copy);

  013ff	8b 5d d8	 mov	 ebx, DWORD PTR _from$1$[ebp]
  01402	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  01405	2b d9		 sub	 ebx, ecx
$LL306@inflate:

; 1186 :             do {
; 1187 :                 *put++ = *from++;

  01407	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  0140a	88 01		 mov	 BYTE PTR [ecx], al
  0140c	41		 inc	 ecx

; 1188 :             } while (--copy);

  0140d	83 ef 01	 sub	 edi, 1
  01410	75 f5		 jne	 SHORT $LL306@inflate

; 1189 :             if (state->length == 0) state->mode = LEN;

  01412	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01415	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  01418	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  0141b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0141e	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  01422	0f 85 55 f7 ff
	ff		 jne	 $LN8@inflate
  01428	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H

; 1190 :             break;

  0142f	e9 49 f7 ff ff	 jmp	 $LN8@inflate
$LN485@inflate:

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  01434	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  01438	0f 84 80 f1 ff
	ff		 je	 $LN887@inflate

; 1193 :             *put++ = (unsigned char)(state->length);

  0143e	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]
  01441	8a 41 44	 mov	 al, BYTE PTR [ecx+68]
  01444	ff 45 e0	 inc	 DWORD PTR _put$1$[ebp]

; 1194 :             left--;

  01447	ff 4d e8	 dec	 DWORD PTR _left$1$[ebp]
  0144a	88 07		 mov	 BYTE PTR [edi], al

; 1195 :             state->mode = LEN;
; 1196 :             break;

  0144c	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  0144f	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
  01456	e9 22 f7 ff ff	 jmp	 $LN8@inflate
$LN487@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  0145b	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0145f	0f 84 e7 00 00
	00		 je	 $LN316@inflate

; 1199 :                 NEEDBITS(32);

  01465	83 fe 20	 cmp	 esi, 32			; 00000020H
  01468	73 30		 jae	 SHORT $LN307@inflate
  0146a	66 0f 1f 44 00
	00		 npad	 6
$LL310@inflate:
  01470	85 db		 test	 ebx, ebx
  01472	0f 84 46 f1 ff
	ff		 je	 $LN887@inflate
  01478	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0147b	8b ce		 mov	 ecx, esi
  0147d	d3 e0		 shl	 eax, cl
  0147f	83 c6 08	 add	 esi, 8
  01482	4b		 dec	 ebx
  01483	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01486	03 d0		 add	 edx, eax
  01488	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0148b	47		 inc	 edi
  0148c	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0148f	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  01492	83 fe 20	 cmp	 esi, 32			; 00000020H
  01495	72 d9		 jb	 SHORT $LL310@inflate
  01497	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN307@inflate:

; 1200 :                 out -= left;

  0149a	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  0149d	29 45 dc	 sub	 DWORD PTR _out$1$[ebp], eax

; 1201 :                 strm->total_out += out;

  014a0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014a3	8b 7d dc	 mov	 edi, DWORD PTR _out$1$[ebp]
  014a6	01 78 14	 add	 DWORD PTR [eax+20], edi

; 1202 :                 state->total += out;

  014a9	8b c7		 mov	 eax, edi
  014ab	01 41 20	 add	 DWORD PTR [ecx+32], eax

; 1203 :                 if ((state->wrap & 4) && out)

  014ae	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  014b2	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  014b5	74 30		 je	 SHORT $LN490@inflate
  014b7	85 c0		 test	 eax, eax
  014b9	74 2c		 je	 SHORT $LN490@inflate

; 1204 :                     strm->adler = state->check =

  014bb	50		 push	 eax
  014bc	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  014bf	2b 45 dc	 sub	 eax, DWORD PTR _out$1$[ebp]
  014c2	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  014c6	50		 push	 eax
  014c7	ff 71 1c	 push	 DWORD PTR [ecx+28]
  014ca	74 07		 je	 SHORT $LN511@inflate
  014cc	e8 00 00 00 00	 call	 _crc32@12
  014d1	eb 05		 jmp	 SHORT $LN512@inflate
$LN511@inflate:
  014d3	e8 00 00 00 00	 call	 _adler32@12
$LN512@inflate:
  014d8	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  014db	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  014de	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  014e1	89 42 30	 mov	 DWORD PTR [edx+48], eax
  014e4	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN490@inflate:

; 1205 :                         UPDATE(state->check, put - out, out);
; 1206 :                 out = left;
; 1207 :                 if ((state->wrap & 4) && (

  014e7	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  014eb	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  014ee	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax
  014f1	74 4f		 je	 SHORT $LN317@inflate
  014f3	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  014f7	8b c2		 mov	 eax, edx
  014f9	75 2c		 jne	 SHORT $LN514@inflate
  014fb	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01500	89 45 d8	 mov	 DWORD PTR tv2843[ebp], eax
  01503	8b c2		 mov	 eax, edx
  01505	c1 e0 10	 shl	 eax, 16			; 00000010H
  01508	01 45 d8	 add	 DWORD PTR tv2843[ebp], eax
  0150b	8b c2		 mov	 eax, edx
  0150d	c1 65 d8 08	 shl	 DWORD PTR tv2843[ebp], 8
  01511	c1 e8 08	 shr	 eax, 8
  01514	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01519	01 45 d8	 add	 DWORD PTR tv2843[ebp], eax
  0151c	8b c2		 mov	 eax, edx
  0151e	c1 e8 18	 shr	 eax, 24			; 00000018H
  01521	01 45 d8	 add	 DWORD PTR tv2843[ebp], eax
  01524	8b 45 d8	 mov	 eax, DWORD PTR tv2843[ebp]
$LN514@inflate:
  01527	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  0152a	74 16		 je	 SHORT $LN317@inflate

; 1208 : #ifdef GUNZIP
; 1209 :                      state->flags ? hold :
; 1210 : #endif
; 1211 :                      ZSWAP32(hold)) != state->check) {
; 1212 :                     strm->msg = (char *)"incorrect data check";

  0152c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0152f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  01536	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  0153d	e9 3b f6 ff ff	 jmp	 $LN8@inflate
$LN317@inflate:

; 1213 :                     state->mode = BAD;
; 1214 :                     break;
; 1215 :                 }
; 1216 :                 INITBITS();

  01542	33 d2		 xor	 edx, edx
  01544	33 f6		 xor	 esi, esi
  01546	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01549	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN316@inflate:

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  0154c	c7 41 04 4f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16207 ; 00003f4fH
$LN492@inflate:

; 1221 :         case LENGTH:
; 1222 :             if (state->wrap && state->flags) {

  01553	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  01557	0f 84 84 00 00
	00		 je	 $LN327@inflate
  0155d	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  01561	74 7e		 je	 SHORT $LN327@inflate

; 1223 :                 NEEDBITS(32);

  01563	83 fe 20	 cmp	 esi, 32			; 00000020H
  01566	73 2a		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  01568	85 db		 test	 ebx, ebx
  0156a	0f 84 4e f0 ff
	ff		 je	 $LN887@inflate
  01570	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  01573	8b ce		 mov	 ecx, esi
  01575	d3 e0		 shl	 eax, cl
  01577	83 c6 08	 add	 esi, 8
  0157a	4b		 dec	 ebx
  0157b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0157e	03 d0		 add	 edx, eax
  01580	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01583	47		 inc	 edi
  01584	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01587	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0158a	83 fe 20	 cmp	 esi, 32			; 00000020H
  0158d	72 d9		 jb	 SHORT $LL321@inflate
  0158f	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN318@inflate:

; 1224 :                 if (hold != (state->total & 0xffffffffUL)) {

  01592	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  01595	74 41		 je	 SHORT $LN328@inflate

; 1225 :                     strm->msg = (char *)"incorrect length check";

  01597	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0159a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  015a1	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  015a8	e9 d0 f5 ff ff	 jmp	 $LN8@inflate
$LN586@inflate:

; 844  :                 RESTORE();

  015ad	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  015b0	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  015b3	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  015b6	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  015b9	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  015bc	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  015bf	89 38		 mov	 DWORD PTR [eax], edi
  015c1	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 845  :                 return Z_NEED_DICT;

  015c4	b8 02 00 00 00	 mov	 eax, 2
  015c9	5f		 pop	 edi
  015ca	89 71 40	 mov	 DWORD PTR [ecx+64], esi
  015cd	5e		 pop	 esi
  015ce	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  015d1	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  015d2	8b e5		 mov	 esp, ebp
  015d4	5d		 pop	 ebp
  015d5	c2 08 00	 ret	 8
$LN328@inflate:

; 1226 :                     state->mode = BAD;
; 1227 :                     break;
; 1228 :                 }
; 1229 :                 INITBITS();

  015d8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  015df	33 f6		 xor	 esi, esi
$LN327@inflate:

; 1230 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1231 :             }
; 1232 : #endif
; 1233 :             state->mode = DONE;

  015e1	c7 41 04 50 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16208 ; 00003f50H
$LN496@inflate:

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;

  015e8	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1236 :             goto inf_leave;

  015ef	e9 ca ef ff ff	 jmp	 $LN887@inflate
$LN497@inflate:

; 1237 :         case BAD:
; 1238 :             ret = Z_DATA_ERROR;

  015f4	c7 45 d4 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH
  015fb	e9 be ef ff ff	 jmp	 $LN887@inflate
$LN863@inflate:
  01600	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01603	e9 bc ef ff ff	 jmp	 $inf_leave$938
$LN503@inflate:

; 1260 :         }
; 1261 :     in -= strm->avail_in;

  01608	8b 45 c8	 mov	 eax, DWORD PTR _in$1$[ebp]
  0160b	2b 47 04	 sub	 eax, DWORD PTR [edi+4]

; 1262 :     out -= strm->avail_out;

  0160e	2b 77 10	 sub	 esi, DWORD PTR [edi+16]

; 1263 :     strm->total_in += in;

  01611	01 47 08	 add	 DWORD PTR [edi+8], eax

; 1264 :     strm->total_out += out;

  01614	01 77 14	 add	 DWORD PTR [edi+20], esi

; 1265 :     state->total += out;

  01617	01 73 20	 add	 DWORD PTR [ebx+32], esi

; 1266 :     if ((state->wrap & 4) && out)

  0161a	f6 43 0c 04	 test	 BYTE PTR [ebx+12], 4
  0161e	89 45 c8	 mov	 DWORD PTR _in$1$[ebp], eax
  01621	89 75 dc	 mov	 DWORD PTR _out$1$[ebp], esi
  01624	74 26		 je	 SHORT $LN504@inflate
  01626	85 f6		 test	 esi, esi
  01628	74 22		 je	 SHORT $LN504@inflate

; 1267 :         strm->adler = state->check =

  0162a	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0162d	56		 push	 esi
  0162e	2b c6		 sub	 eax, esi
  01630	83 7b 14 00	 cmp	 DWORD PTR [ebx+20], 0
  01634	50		 push	 eax
  01635	ff 73 1c	 push	 DWORD PTR [ebx+28]
  01638	74 07		 je	 SHORT $LN515@inflate
  0163a	e8 00 00 00 00	 call	 _crc32@12
  0163f	eb 05		 jmp	 SHORT $LN516@inflate
$LN515@inflate:
  01641	e8 00 00 00 00	 call	 _adler32@12
$LN516@inflate:
  01646	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  01649	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN504@inflate:

; 1268 :             UPDATE(state->check, strm->next_out - out, out);
; 1269 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  0164c	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0164f	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  01655	74 0c		 je	 SHORT $LN517@inflate
  01657	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  0165d	74 04		 je	 SHORT $LN517@inflate
  0165f	33 f6		 xor	 esi, esi
  01661	eb 05		 jmp	 SHORT $LN518@inflate
$LN517@inflate:
  01663	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN518@inflate:
  01668	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0166b	f7 d9		 neg	 ecx
  0166d	c7 45 08 80 00
	00 00		 mov	 DWORD PTR tv2690[ebp], 128 ; 00000080H
  01674	1b c9		 sbb	 ecx, ecx
  01676	33 c0		 xor	 eax, eax
  01678	83 e1 40	 and	 ecx, 64			; 00000040H
  0167b	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  01681	0f 44 45 08	 cmove	 eax, DWORD PTR tv2690[ebp]
  01685	03 ce		 add	 ecx, esi
  01687	03 c1		 add	 eax, ecx
  01689	03 43 40	 add	 eax, DWORD PTR [ebx+64]

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  0168c	83 7d c8 00	 cmp	 DWORD PTR _in$1$[ebp], 0
  01690	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  01693	75 06		 jne	 SHORT $LN507@inflate
  01695	83 7d dc 00	 cmp	 DWORD PTR _out$1$[ebp], 0
  01699	74 06		 je	 SHORT $LN506@inflate
$LN507@inflate:
  0169b	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0169f	75 16		 jne	 SHORT $LN894@inflate
$LN506@inflate:
  016a1	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  016a4	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  016a9	5f		 pop	 edi
  016aa	85 c0		 test	 eax, eax
  016ac	5e		 pop	 esi
  016ad	0f 44 c1	 cmove	 eax, ecx
  016b0	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  016b1	8b e5		 mov	 esp, ebp
  016b3	5d		 pop	 ebp
  016b4	c2 08 00	 ret	 8
$LN894@inflate:
  016b7	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  016ba	5f		 pop	 edi
  016bb	5e		 pop	 esi
  016bc	5b		 pop	 ebx
  016bd	8b e5		 mov	 esp, ebp
  016bf	5d		 pop	 ebp
  016c0	c2 08 00	 ret	 8
$LN333@inflate:

; 646  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 647  :         return Z_STREAM_ERROR;

  016c3	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  016c8	8b e5		 mov	 esp, ebp
  016ca	5d		 pop	 ebp
  016cb	c2 08 00	 ret	 8
  016ce	66 90		 npad	 2
$LN936@inflate:
  016d0	00 00 00 00	 DD	 $LN335@inflate
  016d4	00 00 00 00	 DD	 $LN32@inflate
  016d8	00 00 00 00	 DD	 $LN46@inflate
  016dc	00 00 00 00	 DD	 $LN60@inflate
  016e0	00 00 00 00	 DD	 $LN361@inflate
  016e4	00 00 00 00	 DD	 $LN368@inflate
  016e8	00 00 00 00	 DD	 $LN375@inflate
  016ec	00 00 00 00	 DD	 $LN384@inflate
  016f0	00 00 00 00	 DD	 $LN393@inflate
  016f4	00 00 00 00	 DD	 $LN105@inflate
  016f8	00 00 00 00	 DD	 $LN400@inflate
  016fc	00 00 00 00	 DD	 $LN402@inflate
  01700	00 00 00 00	 DD	 $LN403@inflate
  01704	00 00 00 00	 DD	 $LN141@inflate
  01708	00 00 00 00	 DD	 $LN416@inflate
  0170c	00 00 00 00	 DD	 $LN418@inflate
  01710	00 00 00 00	 DD	 $LN155@inflate
  01714	00 00 00 00	 DD	 $LN532@inflate
  01718	00 00 00 00	 DD	 $LN535@inflate
  0171c	00 00 00 00	 DD	 $LN448@inflate
  01720	00 00 00 00	 DD	 $LN450@inflate
  01724	00 00 00 00	 DD	 $LN461@inflate
  01728	00 00 00 00	 DD	 $LN464@inflate
  0172c	00 00 00 00	 DD	 $LN471@inflate
  01730	00 00 00 00	 DD	 $LN474@inflate
  01734	00 00 00 00	 DD	 $LN485@inflate
  01738	00 00 00 00	 DD	 $LN487@inflate
  0173c	00 00 00 00	 DD	 $LN492@inflate
  01740	00 00 00 00	 DD	 $LN496@inflate
  01744	00 00 00 00	 DD	 $LN497@inflate
  01748	00 00 00 00	 DD	 $LN498@inflate
$LN937@inflate:
  0174c	00 00 00 00	 DD	 $LN408@inflate
  01750	00 00 00 00	 DD	 $LN409@inflate
  01754	00 00 00 00	 DD	 $LN411@inflate
  01758	00 00 00 00	 DD	 $LN412@inflate
_inflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1280 :     struct inflate_state FAR *state;
; 1281 :     if (inflateStateCheck(strm))

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN2@inflateEnd

; 1282 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5e		 pop	 esi

; 1289 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@inflateEnd:

; 1283 :     state = (struct inflate_state FAR *)strm->state;

  0001c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]

; 1284 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0001f	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00022	85 c0		 test	 eax, eax
  00024	74 0c		 je	 SHORT $LN3@inflateEnd
  00026	50		 push	 eax
  00027	ff 76 28	 push	 DWORD PTR [esi+40]
  0002a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0002d	ff d0		 call	 eax
  0002f	83 c4 08	 add	 esp, 8
$LN3@inflateEnd:

; 1285 :     ZFREE(strm, strm->state);

  00032	ff 76 1c	 push	 DWORD PTR [esi+28]
  00035	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00038	ff 76 28	 push	 DWORD PTR [esi+40]
  0003b	ff d0		 call	 eax
  0003d	83 c4 08	 add	 esp, 8

; 1286 :     strm->state = Z_NULL;

  00040	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1287 :     Tracev((stderr, "inflate: end\n"));
; 1288 :     return Z_OK;

  00047	33 c0		 xor	 eax, eax
  00049	5e		 pop	 esi

; 1289 : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateStateCheck
_TEXT	SEGMENT
_inflateStateCheck PROC					; COMDAT
; _strm$ = ecx

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	85 c9		 test	 ecx, ecx
  00002	74 2b		 je	 SHORT $LN3@inflateSta
  00004	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00008	74 25		 je	 SHORT $LN3@inflateSta
  0000a	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0000e	74 1f		 je	 SHORT $LN3@inflateSta

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00010	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  00013	85 c0		 test	 eax, eax
  00015	74 18		 je	 SHORT $LN3@inflateSta
  00017	39 08		 cmp	 DWORD PTR [eax], ecx
  00019	75 14		 jne	 SHORT $LN3@inflateSta
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	3d 34 3f 00 00	 cmp	 eax, 16180		; 00003f34H
  00023	7c 0a		 jl	 SHORT $LN3@inflateSta
  00025	3d 53 3f 00 00	 cmp	 eax, 16211		; 00003f53H
  0002a	7f 03		 jg	 SHORT $LN3@inflateSta

; 115  :         return 1;
; 116  :     return 0;

  0002c	33 c0		 xor	 eax, eax

; 117  : }

  0002e	c3		 ret	 0
$LN3@inflateSta:

; 111  :         return 1;

  0002f	b8 01 00 00 00	 mov	 eax, 1

; 117  : }

  00034	c3		 ret	 0
_inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 09		 je	 SHORT $LN2@inflateRes
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 142  : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  0001d	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00024	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
  0002b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 127  :     strm->msg = Z_NULL;

  00032	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00039	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003c	85 c0		 test	 eax, eax
  0003e	74 06		 je	 SHORT $LN3@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  00040	83 e0 01	 and	 eax, 1
  00043	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN3@inflateRes:

; 130  :     state->mode = HEAD;
; 131  :     state->last = 0;
; 132  :     state->havedict = 0;
; 133  :     state->dmax = 32768U;
; 134  :     state->head = Z_NULL;
; 135  :     state->hold = 0;
; 136  :     state->bits = 0;
; 137  :     state->lencode = state->distcode = state->next = state->codes;

  00046	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  0004c	c7 41 04 34 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16180 ; 00003f34H
  00053	89 41 70	 mov	 DWORD PTR [ecx+112], eax
  00056	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00059	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 138  :     state->sane = 1;
; 139  :     state->back = -1;
; 140  :     Tracev((stderr, "inflate: reset\n"));
; 141  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00065	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0006c	c7 41 18 00 80
	00 00		 mov	 DWORD PTR [ecx+24], 32768 ; 00008000H
  00073	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  0007a	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00081	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  00088	c7 81 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7108], 1
  00092	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 142  : }

  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_state$1$ = 8						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 161  :     int wrap;
; 162  :     struct inflate_state FAR *state;
; 163  : 
; 164  :     /* get the state */
; 165  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	8b cb		 mov	 ecx, ebx
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN2@inflateRes
  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5b		 pop	 ebx

; 193  : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN2@inflateRes:

; 166  :     state = (struct inflate_state FAR *)strm->state;

  0001c	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0001f	56		 push	 esi

; 167  : 
; 168  :     /* extract wrap request from windowBits parameter */
; 169  :     if (windowBits < 0) {

  00020	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  00023	89 45 08	 mov	 DWORD PTR _state$1$[ebp], eax
  00026	57		 push	 edi
  00027	85 f6		 test	 esi, esi
  00029	79 06		 jns	 SHORT $LN3@inflateRes

; 170  :         wrap = 0;

  0002b	33 ff		 xor	 edi, edi

; 171  :         windowBits = -windowBits;

  0002d	f7 de		 neg	 esi

; 172  :     }

  0002f	eb 10		 jmp	 SHORT $LN5@inflateRes
$LN3@inflateRes:

; 173  :     else {
; 174  :         wrap = (windowBits >> 4) + 5;

  00031	8b fe		 mov	 edi, esi
  00033	c1 ff 04	 sar	 edi, 4
  00036	83 c7 05	 add	 edi, 5

; 175  : #ifdef GUNZIP
; 176  :         if (windowBits < 48)

  00039	83 fe 30	 cmp	 esi, 48			; 00000030H
  0003c	7d 03		 jge	 SHORT $LN5@inflateRes

; 177  :             windowBits &= 15;

  0003e	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN5@inflateRes:

; 178  : #endif
; 179  :     }
; 180  : 
; 181  :     /* set number of window bits, free window if different */
; 182  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00041	85 f6		 test	 esi, esi
  00043	74 16		 je	 SHORT $LN6@inflateRes
  00045	83 fe 08	 cmp	 esi, 8
  00048	7c 05		 jl	 SHORT $LN7@inflateRes
  0004a	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0004d	7e 0c		 jle	 SHORT $LN6@inflateRes
$LN7@inflateRes:
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 183  :         return Z_STREAM_ERROR;

  00051	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00056	5b		 pop	 ebx

; 193  : }

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
$LN6@inflateRes:

; 184  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  0005b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0005e	85 c9		 test	 ecx, ecx
  00060	74 1b		 je	 SHORT $LN8@inflateRes
  00062	39 70 28	 cmp	 DWORD PTR [eax+40], esi
  00065	74 16		 je	 SHORT $LN8@inflateRes

; 185  :         ZFREE(strm, state->window);

  00067	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  0006a	51		 push	 ecx
  0006b	ff 73 28	 push	 DWORD PTR [ebx+40]
  0006e	ff d0		 call	 eax

; 186  :         state->window = Z_NULL;

  00070	8b 45 08	 mov	 eax, DWORD PTR _state$1$[ebp]
  00073	83 c4 08	 add	 esp, 8
  00076	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$LN8@inflateRes:

; 187  :     }
; 188  : 
; 189  :     /* update state and reset the rest of it */
; 190  :     state->wrap = wrap;
; 191  :     state->wbits = (unsigned)windowBits;
; 192  :     return inflateReset(strm);

  0007d	53		 push	 ebx
  0007e	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00081	89 70 28	 mov	 DWORD PTR [eax+40], esi
  00084	e8 00 00 00 00	 call	 _inflateReset@4
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 193  : }

  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 244  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_@16

; 245  : }

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 252  :     struct inflate_state FAR *state;
; 253  : 
; 254  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflatePri
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 266  : }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
$LN2@inflatePri:

; 255  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 256  :     if (bits < 0) {

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  0001e	85 c9		 test	 ecx, ecx
  00020	79 14		 jns	 SHORT $LN3@inflatePri

; 257  :         state->hold = 0;

  00022	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 258  :         state->bits = 0;
; 259  :         return Z_OK;

  00029	33 c0		 xor	 eax, eax
  0002b	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 266  : }

  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflatePri:
  00036	56		 push	 esi
  00037	57		 push	 edi

; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00038	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0003b	7f 28		 jg	 SHORT $LN5@inflatePri
  0003d	8b 72 40	 mov	 esi, DWORD PTR [edx+64]
  00040	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00043	83 ff 20	 cmp	 edi, 32			; 00000020H
  00046	77 1d		 ja	 SHORT $LN5@inflatePri

; 262  :     value &= (1L << bits) - 1;

  00048	b8 01 00 00 00	 mov	 eax, 1

; 263  :     state->hold += (unsigned)value << state->bits;
; 264  :     state->bits += (uInt)bits;

  0004d	89 7a 40	 mov	 DWORD PTR [edx+64], edi
  00050	d3 e0		 shl	 eax, cl
  00052	8b ce		 mov	 ecx, esi
  00054	48		 dec	 eax
  00055	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  00058	d3 e0		 shl	 eax, cl
  0005a	01 42 3c	 add	 DWORD PTR [edx+60], eax

; 265  :     return Z_OK;

  0005d	33 c0		 xor	 eax, eax
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 266  : }

  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflatePri:
  00065	5f		 pop	 edi

; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00066	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0006b	5e		 pop	 esi

; 266  : }

  0006c	5d		 pop	 ebp
  0006d	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 281  : #ifdef BUILDFIXED
; 282  :     static int virgin = 1;
; 283  :     static code *lenfix, *distfix;
; 284  :     static code fixed[544];
; 285  : 
; 286  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 287  :     if (virgin) {
; 288  :         unsigned sym, bits;
; 289  :         static code *next;
; 290  : 
; 291  :         /* literal/length table */
; 292  :         sym = 0;
; 293  :         while (sym < 144) state->lens[sym++] = 8;
; 294  :         while (sym < 256) state->lens[sym++] = 9;
; 295  :         while (sym < 280) state->lens[sym++] = 7;
; 296  :         while (sym < 288) state->lens[sym++] = 8;
; 297  :         next = fixed;
; 298  :         lenfix = next;
; 299  :         bits = 9;
; 300  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 301  : 
; 302  :         /* distance table */
; 303  :         sym = 0;
; 304  :         while (sym < 32) state->lens[sym++] = 5;
; 305  :         distfix = next;
; 306  :         bits = 5;
; 307  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 308  : 
; 309  :         /* do this just once */
; 310  :         virgin = 0;
; 311  :     }
; 312  : #else /* !BUILDFIXED */
; 313  : #   include "inffixed.h"
; 314  : #endif /* BUILDFIXED */
; 315  :     state->lencode = lenfix;

  00000	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 316  :     state->lenbits = 9;

  00007	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 317  :     state->distcode = distfix;

  0000e	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 318  :     state->distbits = 5;

  00015	c7 41 5c 05 00
	00 00		 mov	 DWORD PTR [ecx+92], 5

; 319  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
_end$1$ = -4						; size = 4
_copy$ = 8						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = ecx
; _end$ = edx

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b c2		 mov	 eax, edx
  00006	8b d1		 mov	 edx, ecx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	89 45 fc	 mov	 DWORD PTR _end$1$[ebp], eax

; 401  :     struct inflate_state FAR *state;
; 402  :     unsigned dist;
; 403  : 
; 404  :     state = (struct inflate_state FAR *)strm->state;
; 405  : 
; 406  :     /* if it hasn't been done already, allocate space for the window */
; 407  :     if (state->window == Z_NULL) {

  0000d	bf 01 00 00 00	 mov	 edi, 1
  00012	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]
  00015	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00019	75 26		 jne	 SHORT $LN3@updatewind

; 408  :         state->window = (unsigned char FAR *)

  0001b	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0001e	8b c7		 mov	 eax, edi
  00020	d3 e0		 shl	 eax, cl
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	ff 72 28	 push	 DWORD PTR [edx+40]
  00027	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002a	ff d0		 call	 eax
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));
; 411  :         if (state->window == Z_NULL) return 1;

  00032	85 c0		 test	 eax, eax
  00034	75 08		 jne	 SHORT $LN13@updatewind
  00036	8b c7		 mov	 eax, edi
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 444  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN13@updatewind:
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _end$1$[ebp]
$LN3@updatewind:

; 412  :     }
; 413  : 
; 414  :     /* if window not in use yet, initialize */
; 415  :     if (state->wsize == 0) {

  00041	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00045	75 16		 jne	 SHORT $LN4@updatewind

; 416  :         state->wsize = 1U << state->wbits;

  00047	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0004a	d3 e7		 shl	 edi, cl
  0004c	89 7e 2c	 mov	 DWORD PTR [esi+44], edi

; 417  :         state->wnext = 0;

  0004f	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0

; 418  :         state->whave = 0;

  00056	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN4@updatewind:

; 419  :     }
; 420  : 
; 421  :     /* copy state->wsize or less output bytes into the circular window */
; 422  :     if (copy >= state->wsize) {

  0005d	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  00060	53		 push	 ebx
  00061	8b 5d 08	 mov	 ebx, DWORD PTR _copy$[ebp]
  00064	3b df		 cmp	 ebx, edi
  00066	72 25		 jb	 SHORT $LN5@updatewind

; 423  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00068	57		 push	 edi
  00069	2b c7		 sub	 eax, edi
  0006b	50		 push	 eax
  0006c	ff 76 38	 push	 DWORD PTR [esi+56]
  0006f	e8 00 00 00 00	 call	 _memcpy

; 424  :         state->wnext = 0;
; 425  :         state->whave = state->wsize;

  00074	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  0007a	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 441  :         }
; 442  :     }
; 443  :     return 0;

  0007d	33 c0		 xor	 eax, eax
  0007f	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  00086	5b		 pop	 ebx
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 444  : }

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN5@updatewind:

; 426  :     }
; 427  :     else {
; 428  :         dist = state->wsize - state->wnext;

  0008d	2b 7e 34	 sub	 edi, DWORD PTR [esi+52]

; 429  :         if (dist > copy) dist = copy;

  00090	3b fb		 cmp	 edi, ebx
  00092	0f 47 fb	 cmova	 edi, ebx

; 430  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  00095	2b c3		 sub	 eax, ebx
  00097	57		 push	 edi
  00098	50		 push	 eax
  00099	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0009c	03 46 34	 add	 eax, DWORD PTR [esi+52]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _memcpy
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  :         copy -= dist;

  000a8	2b df		 sub	 ebx, edi

; 432  :         if (copy) {

  000aa	74 24		 je	 SHORT $LN8@updatewind

; 433  :             zmemcpy(state->window, end - copy, copy);

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _end$1$[ebp]
  000af	53		 push	 ebx
  000b0	2b c3		 sub	 eax, ebx
  000b2	50		 push	 eax
  000b3	ff 76 38	 push	 DWORD PTR [esi+56]
  000b6	e8 00 00 00 00	 call	 _memcpy

; 434  :             state->wnext = copy;
; 435  :             state->whave = state->wsize;

  000bb	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	89 5e 34	 mov	 DWORD PTR [esi+52], ebx

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  000c4	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000c7	33 c0		 xor	 eax, eax
  000c9	5b		 pop	 ebx
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi

; 444  : }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
$LN8@updatewind:

; 436  :         }
; 437  :         else {
; 438  :             state->wnext += dist;

  000d0	01 7e 34	 add	 DWORD PTR [esi+52], edi

; 439  :             if (state->wnext == state->wsize) state->wnext = 0;

  000d3	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  000d6	39 4e 34	 cmp	 DWORD PTR [esi+52], ecx
  000d9	75 07		 jne	 SHORT $LN10@updatewind
  000db	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
$LN10@updatewind:

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  000e2	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000e5	3b c1		 cmp	 eax, ecx
  000e7	73 05		 jae	 SHORT $LN11@updatewind
  000e9	03 c7		 add	 eax, edi
  000eb	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN11@updatewind:

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000ee	5b		 pop	 ebx
  000ef	5f		 pop	 edi
  000f0	33 c0		 xor	 eax, eax
  000f2	5e		 pop	 esi

; 444  : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1296 :     struct inflate_state FAR *state;
; 1297 : 
; 1298 :     /* check state */
; 1299 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateGet
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1312 : }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
$LN2@inflateGet:
  00018	56		 push	 esi

; 1300 :     state = (struct inflate_state FAR *)strm->state;

  00019	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]

; 1301 : 
; 1302 :     /* copy dictionary */
; 1303 :     if (state->whave && dictionary != Z_NULL) {

  0001c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0001f	85 c0		 test	 eax, eax
  00021	74 2f		 je	 SHORT $LN3@inflateGet
  00023	57		 push	 edi
  00024	8b 7d 0c	 mov	 edi, DWORD PTR _dictionary$[ebp]
  00027	85 ff		 test	 edi, edi
  00029	74 26		 je	 SHORT $LN6@inflateGet

; 1304 :         zmemcpy(dictionary, state->window + state->wnext,

  0002b	2b 46 34	 sub	 eax, DWORD PTR [esi+52]
  0002e	50		 push	 eax
  0002f	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00032	03 46 34	 add	 eax, DWORD PTR [esi+52]
  00035	50		 push	 eax
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 _memcpy

; 1305 :                 state->whave - state->wnext);
; 1306 :         zmemcpy(dictionary + state->whave - state->wnext,

  0003c	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0003f	2b f8		 sub	 edi, eax
  00041	03 7e 30	 add	 edi, DWORD PTR [esi+48]
  00044	50		 push	 eax
  00045	ff 76 38	 push	 DWORD PTR [esi+56]
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 _memcpy
  0004e	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@inflateGet:
  00051	5f		 pop	 edi
$LN3@inflateGet:

; 1307 :                 state->window, state->wnext);
; 1308 :     }
; 1309 :     if (dictLength != Z_NULL)

  00052	8b 4d 10	 mov	 ecx, DWORD PTR _dictLength$[ebp]
  00055	85 c9		 test	 ecx, ecx
  00057	74 05		 je	 SHORT $LN4@inflateGet

; 1310 :         *dictLength = state->whave;

  00059	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0005c	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@inflateGet:

; 1311 :     return Z_OK;

  0005e	33 c0		 xor	 eax, eax
  00060	5e		 pop	 esi

; 1312 : }

  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1318 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1319 :     struct inflate_state FAR *state;
; 1320 :     unsigned long dictid;
; 1321 :     int ret;
; 1322 : 
; 1323 :     /* check state */
; 1324 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00007	8b cf		 mov	 ecx, edi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN2@inflateSet
  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5f		 pop	 edi

; 1347 : }

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
$LN2@inflateSet:
  0001c	56		 push	 esi

; 1325 :     state = (struct inflate_state FAR *)strm->state;

  0001d	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]

; 1326 :     if (state->wrap != 0 && state->mode != DICT)

  00020	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  00024	74 14		 je	 SHORT $LN3@inflateSet
  00026	81 7e 04 3e 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16190 ; 00003f3eH
  0002d	74 0b		 je	 SHORT $LN3@inflateSet

; 1327 :         return Z_STREAM_ERROR;

  0002f	5e		 pop	 esi
  00030	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00035	5f		 pop	 edi

; 1347 : }

  00036	5d		 pop	 ebp
  00037	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflateSet:

; 1328 : 
; 1329 :     /* check for correct dictionary identifier */
; 1330 :     if (state->mode == DICT) {

  0003a	81 7e 04 3e 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16190 ; 00003f3eH
  00041	53		 push	 ebx
  00042	8b 5d 10	 mov	 ebx, DWORD PTR _dictLength$[ebp]
  00045	75 26		 jne	 SHORT $LN5@inflateSet

; 1331 :         dictid = adler32(0L, Z_NULL, 0);
; 1332 :         dictid = adler32(dictid, dictionary, dictLength);

  00047	53		 push	 ebx
  00048	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	e8 00 00 00 00	 call	 _adler32@12
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _adler32@12

; 1333 :         if (dictid != state->check)

  0005c	3b 46 1c	 cmp	 eax, DWORD PTR [esi+28]
  0005f	74 0c		 je	 SHORT $LN5@inflateSet

; 1334 :             return Z_DATA_ERROR;

  00061	5b		 pop	 ebx
  00062	5e		 pop	 esi
  00063	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00068	5f		 pop	 edi

; 1347 : }

  00069	5d		 pop	 ebp
  0006a	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflateSet:

; 1335 :     }
; 1336 : 
; 1337 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1338 :        existing dictionary if appropriate */
; 1339 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  0006d	8b 55 0c	 mov	 edx, DWORD PTR _dictionary$[ebp]
  00070	8b cf		 mov	 ecx, edi
  00072	53		 push	 ebx
  00073	8d 14 1a	 lea	 edx, DWORD PTR [edx+ebx]
  00076	e8 00 00 00 00	 call	 _updatewindow
  0007b	83 c4 04	 add	 esp, 4

; 1340 :     if (ret) {

  0007e	85 c0		 test	 eax, eax
  00080	74 13		 je	 SHORT $LN6@inflateSet

; 1341 :         state->mode = MEM;

  00082	5b		 pop	 ebx
  00083	c7 46 04 52 3f
	00 00		 mov	 DWORD PTR [esi+4], 16210 ; 00003f52H

; 1342 :         return Z_MEM_ERROR;

  0008a	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0008f	5e		 pop	 esi
  00090	5f		 pop	 edi

; 1347 : }

  00091	5d		 pop	 ebp
  00092	c2 0c 00	 ret	 12			; 0000000cH
$LN6@inflateSet:
  00095	5b		 pop	 ebx

; 1343 :     }
; 1344 :     state->havedict = 1;

  00096	c7 46 10 01 00
	00 00		 mov	 DWORD PTR [esi+16], 1

; 1345 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1346 :     return Z_OK;

  0009d	33 c0		 xor	 eax, eax
  0009f	5e		 pop	 esi
  000a0	5f		 pop	 edi

; 1347 : }

  000a1	5d		 pop	 ebp
  000a2	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1352 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1353 :     struct inflate_state FAR *state;
; 1354 : 
; 1355 :     /* check state */
; 1356 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateGet
$LN5@inflateGet:
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1364 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateGet:

; 1357 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0001b	f6 41 0c 02	 test	 BYTE PTR [ecx+12], 2
  0001f	74 ee		 je	 SHORT $LN5@inflateGet

; 1359 : 
; 1360 :     /* save header structure */
; 1361 :     state->head = head;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  00024	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 1362 :     head->done = 0;

  00027	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1363 :     return Z_OK;

  0002e	33 c0		 xor	 eax, eax

; 1364 : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
_len$ = 8						; size = 4
_syncsearch PROC					; COMDAT
; _have$ = ecx
; _buf$ = edx

; 1381 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1382 :     unsigned got;
; 1383 :     unsigned next;
; 1384 : 
; 1385 :     got = *have;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1386 :     next = 0;
; 1387 :     while (next < len && got < 4) {

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00012	89 4d fc	 mov	 DWORD PTR _have$1$[ebp], ecx
  00015	85 ff		 test	 edi, edi
  00017	74 50		 je	 SHORT $LN13@syncsearch
  00019	53		 push	 ebx
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL2@syncsearch:
  00020	83 f8 04	 cmp	 eax, 4
  00023	73 36		 jae	 SHORT $LN14@syncsearch

; 1388 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00025	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  00028	83 f8 02	 cmp	 eax, 2
  0002b	0f b6 cb	 movzx	 ecx, bl
  0002e	1b d2		 sbb	 edx, edx
  00030	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00036	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003c	3b ca		 cmp	 ecx, edx
  0003e	75 03		 jne	 SHORT $LN4@syncsearch

; 1389 :             got++;

  00040	40		 inc	 eax
  00041	eb 10		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1390 :         else if (buf[next])
; 1391 :             got = 0;
; 1392 :         else
; 1393 :             got = 4 - got;

  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	33 d2		 xor	 edx, edx
  0004a	2b c8		 sub	 ecx, eax
  0004c	84 db		 test	 bl, bl
  0004e	8b c1		 mov	 eax, ecx
  00050	0f 45 c2	 cmovne	 eax, edx
$LN7@syncsearch:

; 1394 :         next++;

  00053	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00056	46		 inc	 esi
  00057	3b f7		 cmp	 esi, edi
  00059	72 c5		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1395 :     }
; 1396 :     *have = got;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _have$1$[ebp]
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi
  00060	89 01		 mov	 DWORD PTR [ecx], eax

; 1397 :     return next;

  00062	8b c6		 mov	 eax, esi
  00064	5e		 pop	 esi

; 1398 : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN13@syncsearch:

; 1395 :     }
; 1396 :     *have = got;

  00069	89 01		 mov	 DWORD PTR [ecx], eax

; 1397 :     return next;

  0006b	8b c6		 mov	 eax, esi
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 1398 : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
_in$1$ = 8						; size = 4
_buf$ = 8						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1403 :     unsigned len;               /* number of bytes to look at or looked at */
; 1404 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1405 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1406 :     struct inflate_state FAR *state;
; 1407 : 
; 1408 :     /* check parameters */
; 1409 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	8b cb		 mov	 ecx, ebx
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN4@inflateSyn
  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5b		 pop	 ebx

; 1441 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1410 :     state = (struct inflate_state FAR *)strm->state;
; 1411 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001c	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00020	57		 push	 edi
  00021	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00024	75 11		 jne	 SHORT $LN5@inflateSyn
  00026	83 7f 40 08	 cmp	 DWORD PTR [edi+64], 8
  0002a	73 0b		 jae	 SHORT $LN5@inflateSyn
  0002c	5f		 pop	 edi
  0002d	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00032	5b		 pop	 ebx

; 1441 : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN5@inflateSyn:

; 1412 : 
; 1413 :     /* if first time, start search in bit buffer */
; 1414 :     if (state->mode != SYNC) {

  00037	81 7f 04 53 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16211 ; 00003f53H
  0003e	56		 push	 esi
  0003f	74 4f		 je	 SHORT $LN6@inflateSyn

; 1415 :         state->mode = SYNC;
; 1416 :         state->hold <<= state->bits & 7;

  00041	8b 57 40	 mov	 edx, DWORD PTR [edi+64]

; 1417 :         state->bits -= state->bits & 7;
; 1418 :         len = 0;

  00044	33 f6		 xor	 esi, esi
  00046	8b ca		 mov	 ecx, edx
  00048	c7 47 04 53 3f
	00 00		 mov	 DWORD PTR [edi+4], 16211 ; 00003f53H
  0004f	83 e1 07	 and	 ecx, 7
  00052	d3 67 3c	 shl	 DWORD PTR [edi+60], cl
  00055	2b d1		 sub	 edx, ecx
  00057	89 57 40	 mov	 DWORD PTR [edi+64], edx

; 1419 :         while (state->bits >= 8) {

  0005a	83 fa 08	 cmp	 edx, 8
  0005d	72 1c		 jb	 SHORT $LN3@inflateSyn
  0005f	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
$LL2@inflateSyn:

; 1420 :             buf[len++] = (unsigned char)(state->hold);

  00062	8a 47 3c	 mov	 al, BYTE PTR [edi+60]

; 1421 :             state->hold >>= 8;
; 1422 :             state->bits -= 8;

  00065	83 ea 08	 sub	 edx, 8
  00068	88 44 35 08	 mov	 BYTE PTR _buf$[ebp+esi], al
  0006c	46		 inc	 esi
  0006d	c1 e9 08	 shr	 ecx, 8
  00070	89 4f 3c	 mov	 DWORD PTR [edi+60], ecx
  00073	83 fa 08	 cmp	 edx, 8
  00076	73 ea		 jae	 SHORT $LL2@inflateSyn
  00078	89 57 40	 mov	 DWORD PTR [edi+64], edx
$LN3@inflateSyn:

; 1423 :         }
; 1424 :         state->have = 0;

  0007b	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]

; 1425 :         syncsearch(&(state->have), buf, len);

  0007e	8d 55 08	 lea	 edx, DWORD PTR _buf$[ebp]
  00081	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 _syncsearch
  0008d	83 c4 04	 add	 esp, 4
$LN6@inflateSyn:

; 1426 :     }
; 1427 : 
; 1428 :     /* search available input */
; 1429 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  00090	ff 73 04	 push	 DWORD PTR [ebx+4]
  00093	8b 13		 mov	 edx, DWORD PTR [ebx]
  00095	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  00098	e8 00 00 00 00	 call	 _syncsearch

; 1430 :     strm->avail_in -= len;

  0009d	29 43 04	 sub	 DWORD PTR [ebx+4], eax
  000a0	83 c4 04	 add	 esp, 4

; 1431 :     strm->next_in += len;

  000a3	01 03		 add	 DWORD PTR [ebx], eax

; 1432 :     strm->total_in += len;

  000a5	01 43 08	 add	 DWORD PTR [ebx+8], eax

; 1433 : 
; 1434 :     /* return no joy or set up to restart inflate() on a new block */
; 1435 :     if (state->have != 4) return Z_DATA_ERROR;

  000a8	83 7f 6c 04	 cmp	 DWORD PTR [edi+108], 4
  000ac	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000af	89 45 08	 mov	 DWORD PTR _in$1$[ebp], eax
  000b2	74 0c		 je	 SHORT $LN7@inflateSyn
  000b4	5e		 pop	 esi
  000b5	5f		 pop	 edi
  000b6	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000bb	5b		 pop	 ebx

; 1441 : }

  000bc	5d		 pop	 ebp
  000bd	c2 04 00	 ret	 4
$LN7@inflateSyn:

; 1436 :     in = strm->total_in;  out = strm->total_out;

  000c0	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 1437 :     inflateReset(strm);

  000c3	53		 push	 ebx
  000c4	e8 00 00 00 00	 call	 _inflateReset@4

; 1438 :     strm->total_in = in;  strm->total_out = out;

  000c9	8b 45 08	 mov	 eax, DWORD PTR _in$1$[ebp]
  000cc	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000cf	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1439 :     state->mode = TYPE;
; 1440 :     return Z_OK;

  000d2	33 c0		 xor	 eax, eax
  000d4	5e		 pop	 esi
  000d5	c7 47 04 3f 3f
	00 00		 mov	 DWORD PTR [edi+4], 16191 ; 00003f3fH
  000dc	5f		 pop	 edi
  000dd	5b		 pop	 ebx

; 1441 : }

  000de	5d		 pop	 ebp
  000df	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1454 :     struct inflate_state FAR *state;
; 1455 : 
; 1456 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateSyn
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1459 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateSyn:

; 1457 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1458 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 04 41 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16193 ; 00003f41H
  00022	75 0f		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00028	75 09		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1459 : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1458 :     return state->mode == STORED && state->bits == 0;

  00033	33 c0		 xor	 eax, eax

; 1459 : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_window$1$ = 12						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1464 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1465 :     struct inflate_state FAR *state;
; 1466 :     struct inflate_state FAR *copy;
; 1467 :     unsigned char FAR *window;
; 1468 :     unsigned wsize;
; 1469 : 
; 1470 :     /* check input */
; 1471 :     if (inflateStateCheck(source) || dest == Z_NULL)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _source$[ebp]
  00007	8b cf		 mov	 ecx, edi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 2e 01 00
	00		 jne	 $LN3@inflateCop
  00016	39 45 08	 cmp	 DWORD PTR _dest$[ebp], eax
  00019	0f 84 25 01 00
	00		 je	 $LN3@inflateCop

; 1473 :     state = (struct inflate_state FAR *)source->state;
; 1474 : 
; 1475 :     /* allocate space */
; 1476 :     copy = (struct inflate_state FAR *)

  0001f	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00022	53		 push	 ebx
  00023	8b 5f 1c	 mov	 ebx, DWORD PTR [edi+28]
  00026	56		 push	 esi
  00027	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0002c	6a 01		 push	 1
  0002e	ff 77 28	 push	 DWORD PTR [edi+40]
  00031	ff d0		 call	 eax
  00033	8b f0		 mov	 esi, eax
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1477 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1478 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00038	85 f6		 test	 esi, esi
  0003a	74 38		 je	 SHORT $LN12@inflateCop

; 1479 :     window = Z_NULL;
; 1480 :     if (state->window != Z_NULL) {

  0003c	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00040	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  00047	74 37		 je	 SHORT $LN6@inflateCop

; 1481 :         window = (unsigned char FAR *)

  00049	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	d3 e0		 shl	 eax, cl
  00053	6a 01		 push	 1
  00055	50		 push	 eax
  00056	ff 77 28	 push	 DWORD PTR [edi+40]
  00059	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0005c	ff d0		 call	 eax
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	89 45 0c	 mov	 DWORD PTR _window$1$[ebp], eax

; 1482 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1483 :         if (window == Z_NULL) {

  00064	85 c0		 test	 eax, eax
  00066	75 18		 jne	 SHORT $LN6@inflateCop

; 1484 :             ZFREE(source, copy);

  00068	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0006b	56		 push	 esi
  0006c	ff 77 28	 push	 DWORD PTR [edi+40]
  0006f	ff d0		 call	 eax
  00071	83 c4 08	 add	 esp, 8
$LN12@inflateCop:

; 1485 :             return Z_MEM_ERROR;

  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0007b	5f		 pop	 edi

; 1506 : }

  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
$LN6@inflateCop:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     /* copy state */
; 1490 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00080	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00083	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 1491 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  00086	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0008b	53		 push	 ebx
  0008c	56		 push	 esi
  0008d	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00090	0f 10 47 10	 movups	 xmm0, XMMWORD PTR [edi+16]
  00094	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  00098	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [edi+32]
  0009c	0f 11 40 20	 movups	 XMMWORD PTR [eax+32], xmm0
  000a0	f3 0f 7e 47 30	 movq	 xmm0, QWORD PTR [edi+48]
  000a5	66 0f d6 40 30	 movq	 QWORD PTR [eax+48], xmm0
  000aa	e8 00 00 00 00	 call	 _memcpy

; 1492 :     copy->strm = dest;

  000af	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]

; 1493 :     if (state->lencode >= state->codes &&

  000b2	8d 83 34 05 00
	00		 lea	 eax, DWORD PTR [ebx+1332]
  000b8	89 3e		 mov	 DWORD PTR [esi], edi
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bd	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  000c0	3b c8		 cmp	 ecx, eax
  000c2	72 38		 jb	 SHORT $LN7@inflateCop
  000c4	8d 83 c0 1b 00
	00		 lea	 eax, DWORD PTR [ebx+7104]
  000ca	3b c8		 cmp	 ecx, eax
  000cc	77 2e		 ja	 SHORT $LN7@inflateCop

; 1494 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1495 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000ce	2b cb		 sub	 ecx, ebx
  000d0	8d 81 cc fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1332]
  000d6	c1 f8 02	 sar	 eax, 2
  000d9	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000de	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000e1	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 1496 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000e4	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  000e7	2b c3		 sub	 eax, ebx
  000e9	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  000ee	c1 f8 02	 sar	 eax, 2
  000f1	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000f6	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000f9	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN7@inflateCop:

; 1497 :     }
; 1498 :     copy->next = copy->codes + (state->next - state->codes);

  000fc	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]
  000ff	2b c3		 sub	 eax, ebx
  00101	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00106	c1 f8 02	 sar	 eax, 2
  00109	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  0010e	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00111	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 1499 :     if (window != Z_NULL) {

  00114	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  00117	85 c0		 test	 eax, eax
  00119	74 1a		 je	 SHORT $LN8@inflateCop

; 1500 :         wsize = 1U << state->wbits;

  0011b	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  0011e	ba 01 00 00 00	 mov	 edx, 1
  00123	d3 e2		 shl	 edx, cl

; 1501 :         zmemcpy(window, state->window, wsize);

  00125	52		 push	 edx
  00126	ff 73 38	 push	 DWORD PTR [ebx+56]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _memcpy
  0012f	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@inflateCop:

; 1502 :     }
; 1503 :     copy->window = window;

  00135	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 1504 :     dest->state = (struct internal_state FAR *)copy;
; 1505 :     return Z_OK;

  00138	33 c0		 xor	 eax, eax
  0013a	89 77 1c	 mov	 DWORD PTR [edi+28], esi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx
  0013f	5f		 pop	 edi

; 1506 : }

  00140	5d		 pop	 ebp
  00141	c2 08 00	 ret	 8
$LN3@inflateCop:

; 1472 :         return Z_STREAM_ERROR;

  00144	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00149	5f		 pop	 edi

; 1506 : }

  0014a	5d		 pop	 ebp
  0014b	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1512 :     struct inflate_state FAR *state;
; 1513 : 
; 1514 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateUnd
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1523 : #endif
; 1524 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateUnd:

; 1515 :     state = (struct inflate_state FAR *)strm->state;
; 1516 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1517 :     state->sane = !subvert;
; 1518 :     return Z_OK;
; 1519 : #else
; 1520 :     (void)subvert;
; 1521 :     state->sane = 1;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001b	c7 80 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7108], 1

; 1522 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1523 : #endif
; 1524 : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateValidate@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_check$ = 12						; size = 4
_inflateValidate@8 PROC					; COMDAT

; 1529 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1530 :     struct inflate_state FAR *state;
; 1531 : 
; 1532 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateVal
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1539 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateVal:

; 1533 :     state = (struct inflate_state FAR *)strm->state;
; 1534 :     if (check)

  00018	83 7d 0c 00	 cmp	 DWORD PTR _check$[ebp], 0
  0001c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001f	74 0a		 je	 SHORT $LN3@inflateVal

; 1535 :         state->wrap |= 4;

  00021	83 48 0c 04	 or	 DWORD PTR [eax+12], 4

; 1538 :     return Z_OK;

  00025	33 c0		 xor	 eax, eax

; 1539 : }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
$LN3@inflateVal:

; 1536 :     else
; 1537 :         state->wrap &= ~4;

  0002b	83 60 0c fb	 and	 DWORD PTR [eax+12], -5	; fffffffbH

; 1538 :     return Z_OK;

  0002f	33 c0		 xor	 eax, eax

; 1539 : }

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_inflateValidate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1544 :     struct inflate_state FAR *state;
; 1545 : 
; 1546 :     if (inflateStateCheck(strm))

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateMar

; 1547 :         return -(1L << 16);

  0000f	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateMar:

; 1548 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 12		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00029	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0002f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00032	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN6@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00038	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003e	75 18		 jne	 SHORT $LN4@inflateMar
  00040	8b 88 cc 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7116]
  00046	2b 48 44	 sub	 ecx, DWORD PTR [eax+68]
  00049	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0004f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00052	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN4@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00058	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0005e	33 c9		 xor	 ecx, ecx
  00060	c1 e0 10	 shl	 eax, 16			; 00000010H
  00063	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\usuarios\gustavo\descargas\zlib-1.2.11\zlib-1.2.11\inflate.c
;	COMDAT _inflateCodesUsed@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateCodesUsed@4 PROC				; COMDAT

; 1556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1557 :     struct inflate_state FAR *state;
; 1558 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateCod
  0000f	83 c8 ff	 or	 eax, -1

; 1561 : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN2@inflateCod:

; 1559 :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1560 :     return (unsigned long)(state->next - state->codes);

  00019	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  0001c	2b c1		 sub	 eax, ecx
  0001e	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00023	c1 f8 02	 sar	 eax, 2

; 1561 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
_inflateCodesUsed@4 ENDP
_TEXT	ENDS
END
